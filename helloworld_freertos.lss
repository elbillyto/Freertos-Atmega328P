
helloworld_freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  00001b32  00001bc6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001b32  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000673  0080010e  0080010e  00001bd4  2**0
                  ALLOC
  3 .stab         000051e4  00000000  00000000  00001bd4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000027dd  00000000  00000000  00006db8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 84 0d 	jmp	0x1b08	; 0x1b08 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e2 e3       	ldi	r30, 0x32	; 50
      7c:	fb e1       	ldi	r31, 0x1B	; 27
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	ae 30       	cpi	r26, 0x0E	; 14
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	17 e0       	ldi	r17, 0x07	; 7
      8c:	ae e0       	ldi	r26, 0x0E	; 14
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a1 38       	cpi	r26, 0x81	; 129
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 5e 00 	call	0xbc	; 0xbc <main>
      9e:	0c 94 97 0d 	jmp	0x1b2e	; 0x1b2e <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vBlinkLed>:
 * \brief
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vBlinkLed(void* pvParameters)
{
      a6:	1f 93       	push	r17
    DDRB |= _BV(PB5);
      a8:	25 9a       	sbi	0x04, 5	; 4

    for ( ;; )
    {
        PORTB ^= _BV(PB5);
      aa:	10 e2       	ldi	r17, 0x20	; 32
      ac:	85 b1       	in	r24, 0x05	; 5
      ae:	81 27       	eor	r24, r17
      b0:	85 b9       	out	0x05, r24	; 5
        vTaskDelay(500);
      b2:	84 ef       	ldi	r24, 0xF4	; 244
      b4:	91 e0       	ldi	r25, 0x01	; 1
      b6:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <vTaskDelay>
      ba:	f8 cf       	rjmp	.-16     	; 0xac <vBlinkLed+0x6>

000000bc <main>:
 * \brief Main function.
 *
 * \return
 ******************************************************************************/
int main(void)
{
      bc:	af 92       	push	r10
      be:	bf 92       	push	r11
      c0:	cf 92       	push	r12
      c2:	df 92       	push	r13
      c4:	ef 92       	push	r14
      c6:	ff 92       	push	r15
      c8:	0f 93       	push	r16
      ca:	df 93       	push	r29
      cc:	cf 93       	push	r28
      ce:	00 d0       	rcall	.+0      	; 0xd0 <main+0x14>
      d0:	cd b7       	in	r28, 0x3d	; 61
      d2:	de b7       	in	r29, 0x3e	; 62
    // Create task.
    xTaskHandle blink_handle;
    xTaskCreate
      d4:	83 e5       	ldi	r24, 0x53	; 83
      d6:	90 e0       	ldi	r25, 0x00	; 0
      d8:	60 e0       	ldi	r22, 0x00	; 0
      da:	71 e0       	ldi	r23, 0x01	; 1
      dc:	45 e5       	ldi	r20, 0x55	; 85
      de:	50 e0       	ldi	r21, 0x00	; 0
      e0:	20 e0       	ldi	r18, 0x00	; 0
      e2:	30 e0       	ldi	r19, 0x00	; 0
      e4:	00 e0       	ldi	r16, 0x00	; 0
      e6:	7e 01       	movw	r14, r28
      e8:	08 94       	sec
      ea:	e1 1c       	adc	r14, r1
      ec:	f1 1c       	adc	r15, r1
      ee:	cc 24       	eor	r12, r12
      f0:	dd 24       	eor	r13, r13
      f2:	aa 24       	eor	r10, r10
      f4:	bb 24       	eor	r11, r11
      f6:	0e 94 c5 00 	call	0x18a	; 0x18a <xTaskGenericCreate>
        mainLED_TASK_PRIORITY,
        &blink_handle
    );

    // Start scheduler.
    vTaskStartScheduler();
      fa:	0e 94 19 02 	call	0x432	; 0x432 <vTaskStartScheduler>

    return 0;
}
      fe:	80 e0       	ldi	r24, 0x00	; 0
     100:	90 e0       	ldi	r25, 0x00	; 0
     102:	0f 90       	pop	r0
     104:	0f 90       	pop	r0
     106:	cf 91       	pop	r28
     108:	df 91       	pop	r29
     10a:	0f 91       	pop	r16
     10c:	ff 90       	pop	r15
     10e:	ef 90       	pop	r14
     110:	df 90       	pop	r13
     112:	cf 90       	pop	r12
     114:	bf 90       	pop	r11
     116:	af 90       	pop	r10
     118:	08 95       	ret

0000011a <vApplicationIdleHook>:
 * \brief
 ******************************************************************************/
void vApplicationIdleHook(void)
{

}
     11a:	08 95       	ret

0000011c <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
     11c:	cf 93       	push	r28
     11e:	df 93       	push	r29
     120:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     122:	e0 91 0e 01 	lds	r30, 0x010E
     126:	f0 91 0f 01 	lds	r31, 0x010F
     12a:	93 83       	std	Z+3, r25	; 0x03
     12c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     12e:	80 91 11 01 	lds	r24, 0x0111
     132:	90 91 12 01 	lds	r25, 0x0112
     136:	c8 17       	cp	r28, r24
     138:	d9 07       	cpc	r29, r25
     13a:	68 f4       	brcc	.+26     	; 0x156 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     13c:	80 91 43 01 	lds	r24, 0x0143
     140:	90 91 44 01 	lds	r25, 0x0144
     144:	60 91 0e 01 	lds	r22, 0x010E
     148:	70 91 0f 01 	lds	r23, 0x010F
     14c:	6e 5f       	subi	r22, 0xFE	; 254
     14e:	7f 4f       	sbci	r23, 0xFF	; 255
     150:	0e 94 c8 09 	call	0x1390	; 0x1390 <vListInsert>
     154:	17 c0       	rjmp	.+46     	; 0x184 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     156:	80 91 45 01 	lds	r24, 0x0145
     15a:	90 91 46 01 	lds	r25, 0x0146
     15e:	60 91 0e 01 	lds	r22, 0x010E
     162:	70 91 0f 01 	lds	r23, 0x010F
     166:	6e 5f       	subi	r22, 0xFE	; 254
     168:	7f 4f       	sbci	r23, 0xFF	; 255
     16a:	0e 94 c8 09 	call	0x1390	; 0x1390 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     16e:	80 91 0b 01 	lds	r24, 0x010B
     172:	90 91 0c 01 	lds	r25, 0x010C
     176:	c8 17       	cp	r28, r24
     178:	d9 07       	cpc	r29, r25
     17a:	20 f4       	brcc	.+8      	; 0x184 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     17c:	d0 93 0c 01 	sts	0x010C, r29
     180:	c0 93 0b 01 	sts	0x010B, r28
		}
	}
}
     184:	df 91       	pop	r29
     186:	cf 91       	pop	r28
     188:	08 95       	ret

0000018a <xTaskGenericCreate>:
	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     18a:	2f 92       	push	r2
     18c:	3f 92       	push	r3
     18e:	5f 92       	push	r5
     190:	6f 92       	push	r6
     192:	7f 92       	push	r7
     194:	8f 92       	push	r8
     196:	9f 92       	push	r9
     198:	af 92       	push	r10
     19a:	bf 92       	push	r11
     19c:	cf 92       	push	r12
     19e:	df 92       	push	r13
     1a0:	ef 92       	push	r14
     1a2:	ff 92       	push	r15
     1a4:	0f 93       	push	r16
     1a6:	1f 93       	push	r17
     1a8:	cf 93       	push	r28
     1aa:	df 93       	push	r29
     1ac:	1c 01       	movw	r2, r24
     1ae:	16 2f       	mov	r17, r22
     1b0:	57 2e       	mov	r5, r23
     1b2:	5a 01       	movw	r10, r20
     1b4:	39 01       	movw	r6, r18
     1b6:	47 01       	movw	r8, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
     1b8:	81 e2       	ldi	r24, 0x21	; 33
     1ba:	90 e0       	ldi	r25, 0x00	; 0
     1bc:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <pvPortMalloc>
     1c0:	e8 2e       	mov	r14, r24
     1c2:	e7 01       	movw	r28, r14
     1c4:	7e 01       	movw	r14, r28
     1c6:	f9 2e       	mov	r15, r25
     1c8:	e7 01       	movw	r28, r14

	if( pxNewTCB != NULL )
     1ca:	20 97       	sbiw	r28, 0x00	; 0
     1cc:	09 f4       	brne	.+2      	; 0x1d0 <xTaskGenericCreate+0x46>
     1ce:	dc c0       	rjmp	.+440    	; 0x388 <xTaskGenericCreate+0x1fe>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     1d0:	c1 14       	cp	r12, r1
     1d2:	d1 04       	cpc	r13, r1
     1d4:	29 f4       	brne	.+10     	; 0x1e0 <xTaskGenericCreate+0x56>
     1d6:	c5 01       	movw	r24, r10
     1d8:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <pvPortMalloc>
     1dc:	c8 2e       	mov	r12, r24
     1de:	d9 2e       	mov	r13, r25
     1e0:	d8 8e       	std	Y+24, r13	; 0x18
     1e2:	cf 8a       	std	Y+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
     1e4:	c1 14       	cp	r12, r1
     1e6:	d1 04       	cpc	r13, r1
     1e8:	21 f4       	brne	.+8      	; 0x1f2 <xTaskGenericCreate+0x68>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
     1ea:	ce 01       	movw	r24, r28
     1ec:	0e 94 33 0c 	call	0x1866	; 0x1866 <vPortFree>
     1f0:	cb c0       	rjmp	.+406    	; 0x388 <xTaskGenericCreate+0x1fe>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
     1f2:	c6 01       	movw	r24, r12
     1f4:	65 ea       	ldi	r22, 0xA5	; 165
     1f6:	70 e0       	ldi	r23, 0x00	; 0
     1f8:	a5 01       	movw	r20, r10
     1fa:	0e 94 90 0d 	call	0x1b20	; 0x1b20 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     1fe:	08 94       	sec
     200:	a1 08       	sbc	r10, r1
     202:	b1 08       	sbc	r11, r1
     204:	ef 88       	ldd	r14, Y+23	; 0x17
     206:	f8 8c       	ldd	r15, Y+24	; 0x18
     208:	ea 0c       	add	r14, r10
     20a:	fb 1c       	adc	r15, r11

	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
     20c:	ae 01       	movw	r20, r28
     20e:	47 5e       	subi	r20, 0xE7	; 231
     210:	5f 4f       	sbci	r21, 0xFF	; 255
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     212:	e1 2f       	mov	r30, r17
     214:	f5 2d       	mov	r31, r5

	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
     216:	28 e0       	ldi	r18, 0x08	; 8
     218:	cf 01       	movw	r24, r30
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     21a:	31 91       	ld	r19, Z+
     21c:	da 01       	movw	r26, r20
     21e:	3d 93       	st	X+, r19
     220:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     222:	dc 01       	movw	r26, r24
     224:	8c 91       	ld	r24, X
     226:	88 23       	and	r24, r24
     228:	11 f0       	breq	.+4      	; 0x22e <xTaskGenericCreate+0xa4>
     22a:	21 50       	subi	r18, 0x01	; 1
static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
     22c:	a9 f7       	brne	.-22     	; 0x218 <xTaskGenericCreate+0x8e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
     22e:	18 a2       	std	Y+32, r1	; 0x20
     230:	10 2f       	mov	r17, r16
     232:	04 30       	cpi	r16, 0x04	; 4
     234:	08 f0       	brcs	.+2      	; 0x238 <xTaskGenericCreate+0xae>
     236:	13 e0       	ldi	r17, 0x03	; 3
	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
	{
		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
     238:	1e 8b       	std	Y+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     23a:	e2 e0       	ldi	r30, 0x02	; 2
     23c:	ae 2e       	mov	r10, r30
     23e:	b1 2c       	mov	r11, r1
     240:	ac 0e       	add	r10, r28
     242:	bd 1e       	adc	r11, r29
     244:	c5 01       	movw	r24, r10
     246:	0e 94 a1 09 	call	0x1342	; 0x1342 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     24a:	ce 01       	movw	r24, r28
     24c:	0c 96       	adiw	r24, 0x0c	; 12
     24e:	0e 94 a1 09 	call	0x1342	; 0x1342 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     252:	d9 87       	std	Y+9, r29	; 0x09
     254:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     256:	84 e0       	ldi	r24, 0x04	; 4
     258:	90 e0       	ldi	r25, 0x00	; 0
     25a:	81 1b       	sub	r24, r17
     25c:	91 09       	sbc	r25, r1
     25e:	9d 87       	std	Y+13, r25	; 0x0d
     260:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     262:	db 8b       	std	Y+19, r29	; 0x13
     264:	ca 8b       	std	Y+18, r28	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     266:	c7 01       	movw	r24, r14
     268:	b1 01       	movw	r22, r2
     26a:	a3 01       	movw	r20, r6
     26c:	0e 94 43 0c 	call	0x1886	; 0x1886 <pxPortInitialiseStack>
     270:	99 83       	std	Y+1, r25	; 0x01
     272:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     274:	81 14       	cp	r8, r1
     276:	91 04       	cpc	r9, r1
     278:	19 f0       	breq	.+6      	; 0x280 <xTaskGenericCreate+0xf6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     27a:	f4 01       	movw	r30, r8
     27c:	d1 83       	std	Z+1, r29	; 0x01
     27e:	c0 83       	st	Z, r28
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     280:	0f b6       	in	r0, 0x3f	; 63
     282:	f8 94       	cli
     284:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     286:	80 91 48 01 	lds	r24, 0x0148
     28a:	8f 5f       	subi	r24, 0xFF	; 255
     28c:	80 93 48 01 	sts	0x0148, r24
			if( pxCurrentTCB == NULL )
     290:	80 91 0e 01 	lds	r24, 0x010E
     294:	90 91 0f 01 	lds	r25, 0x010F
     298:	00 97       	sbiw	r24, 0x00	; 0
     29a:	e9 f5       	brne	.+122    	; 0x316 <xTaskGenericCreate+0x18c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     29c:	d0 93 0f 01 	sts	0x010F, r29
     2a0:	c0 93 0e 01 	sts	0x010E, r28

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     2a4:	80 91 48 01 	lds	r24, 0x0148
     2a8:	81 30       	cpi	r24, 0x01	; 1
     2aa:	09 f0       	breq	.+2      	; 0x2ae <xTaskGenericCreate+0x124>
     2ac:	43 c0       	rjmp	.+134    	; 0x334 <xTaskGenericCreate+0x1aa>
     2ae:	ee 24       	eor	r14, r14
     2b0:	ff 24       	eor	r15, r15
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     2b2:	c7 01       	movw	r24, r14
     2b4:	73 e0       	ldi	r23, 0x03	; 3
     2b6:	88 0f       	add	r24, r24
     2b8:	99 1f       	adc	r25, r25
     2ba:	7a 95       	dec	r23
     2bc:	e1 f7       	brne	.-8      	; 0x2b6 <xTaskGenericCreate+0x12c>
     2be:	8e 0d       	add	r24, r14
     2c0:	9f 1d       	adc	r25, r15
     2c2:	8a 5e       	subi	r24, 0xEA	; 234
     2c4:	9e 4f       	sbci	r25, 0xFE	; 254
     2c6:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
     2ca:	08 94       	sec
     2cc:	e1 1c       	adc	r14, r1
     2ce:	f1 1c       	adc	r15, r1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
     2d0:	f4 e0       	ldi	r31, 0x04	; 4
     2d2:	ef 16       	cp	r14, r31
     2d4:	f1 04       	cpc	r15, r1
     2d6:	69 f7       	brne	.-38     	; 0x2b2 <xTaskGenericCreate+0x128>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
     2d8:	65 e5       	ldi	r22, 0x55	; 85
     2da:	e6 2e       	mov	r14, r22
     2dc:	61 e0       	ldi	r22, 0x01	; 1
     2de:	f6 2e       	mov	r15, r22
     2e0:	c7 01       	movw	r24, r14
     2e2:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     2e6:	5e e5       	ldi	r21, 0x5E	; 94
     2e8:	c5 2e       	mov	r12, r21
     2ea:	51 e0       	ldi	r21, 0x01	; 1
     2ec:	d5 2e       	mov	r13, r21
     2ee:	c6 01       	movw	r24, r12
     2f0:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     2f4:	8a e3       	ldi	r24, 0x3A	; 58
     2f6:	91 e0       	ldi	r25, 0x01	; 1
     2f8:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     2fc:	8a e4       	ldi	r24, 0x4A	; 74
     2fe:	91 e0       	ldi	r25, 0x01	; 1
     300:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     304:	f0 92 46 01 	sts	0x0146, r15
     308:	e0 92 45 01 	sts	0x0145, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     30c:	d0 92 44 01 	sts	0x0144, r13
     310:	c0 92 43 01 	sts	0x0143, r12
     314:	0f c0       	rjmp	.+30     	; 0x334 <xTaskGenericCreate+0x1aa>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     316:	80 91 49 01 	lds	r24, 0x0149
     31a:	88 23       	and	r24, r24
     31c:	59 f4       	brne	.+22     	; 0x334 <xTaskGenericCreate+0x1aa>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     31e:	e0 91 0e 01 	lds	r30, 0x010E
     322:	f0 91 0f 01 	lds	r31, 0x010F
     326:	86 89       	ldd	r24, Z+22	; 0x16
     328:	08 17       	cp	r16, r24
     32a:	20 f0       	brcs	.+8      	; 0x334 <xTaskGenericCreate+0x1aa>
					{
						pxCurrentTCB = pxNewTCB;
     32c:	d0 93 0f 01 	sts	0x010F, r29
     330:	c0 93 0e 01 	sts	0x010E, r28
					}
				}
			}

			uxTaskNumber++;
     334:	80 91 54 01 	lds	r24, 0x0154
     338:	8f 5f       	subi	r24, 0xFF	; 255
     33a:	80 93 54 01 	sts	0x0154, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     33e:	2e 89       	ldd	r18, Y+22	; 0x16
     340:	80 91 15 01 	lds	r24, 0x0115
     344:	82 17       	cp	r24, r18
     346:	10 f4       	brcc	.+4      	; 0x34c <xTaskGenericCreate+0x1c2>
     348:	20 93 15 01 	sts	0x0115, r18
     34c:	30 e0       	ldi	r19, 0x00	; 0
     34e:	c9 01       	movw	r24, r18
     350:	43 e0       	ldi	r20, 0x03	; 3
     352:	88 0f       	add	r24, r24
     354:	99 1f       	adc	r25, r25
     356:	4a 95       	dec	r20
     358:	e1 f7       	brne	.-8      	; 0x352 <xTaskGenericCreate+0x1c8>
     35a:	82 0f       	add	r24, r18
     35c:	93 1f       	adc	r25, r19
     35e:	8a 5e       	subi	r24, 0xEA	; 234
     360:	9e 4f       	sbci	r25, 0xFE	; 254
     362:	b5 01       	movw	r22, r10
     364:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     368:	0f 90       	pop	r0
     36a:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     36c:	80 91 49 01 	lds	r24, 0x0149
     370:	88 23       	and	r24, r24
     372:	61 f0       	breq	.+24     	; 0x38c <xTaskGenericCreate+0x202>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     374:	e0 91 0e 01 	lds	r30, 0x010E
     378:	f0 91 0f 01 	lds	r31, 0x010F
     37c:	86 89       	ldd	r24, Z+22	; 0x16
     37e:	80 17       	cp	r24, r16
     380:	28 f4       	brcc	.+10     	; 0x38c <xTaskGenericCreate+0x202>
			{
				taskYIELD_IF_USING_PREEMPTION();
     382:	0e 94 ce 0c 	call	0x199c	; 0x199c <vPortYield>
     386:	02 c0       	rjmp	.+4      	; 0x38c <xTaskGenericCreate+0x202>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     388:	8f ef       	ldi	r24, 0xFF	; 255
     38a:	01 c0       	rjmp	.+2      	; 0x38e <xTaskGenericCreate+0x204>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
     38c:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
     38e:	df 91       	pop	r29
     390:	cf 91       	pop	r28
     392:	1f 91       	pop	r17
     394:	0f 91       	pop	r16
     396:	ff 90       	pop	r15
     398:	ef 90       	pop	r14
     39a:	df 90       	pop	r13
     39c:	cf 90       	pop	r12
     39e:	bf 90       	pop	r11
     3a0:	af 90       	pop	r10
     3a2:	9f 90       	pop	r9
     3a4:	8f 90       	pop	r8
     3a6:	7f 90       	pop	r7
     3a8:	6f 90       	pop	r6
     3aa:	5f 90       	pop	r5
     3ac:	3f 90       	pop	r3
     3ae:	2f 90       	pop	r2
     3b0:	08 95       	ret

000003b2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
     3b2:	0f 93       	push	r16
     3b4:	1f 93       	push	r17
     3b6:	cf 93       	push	r28
     3b8:	df 93       	push	r29
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
     3ba:	0f b6       	in	r0, 0x3f	; 63
     3bc:	f8 94       	cli
     3be:	0f 92       	push	r0
		{
			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     3c0:	00 97       	sbiw	r24, 0x00	; 0
     3c2:	29 f4       	brne	.+10     	; 0x3ce <vTaskDelete+0x1c>
     3c4:	c0 91 0e 01 	lds	r28, 0x010E
     3c8:	d0 91 0f 01 	lds	r29, 0x010F
     3cc:	01 c0       	rjmp	.+2      	; 0x3d0 <vTaskDelete+0x1e>
     3ce:	ec 01       	movw	r28, r24

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
     3d0:	8e 01       	movw	r16, r28
     3d2:	0e 5f       	subi	r16, 0xFE	; 254
     3d4:	1f 4f       	sbci	r17, 0xFF	; 255
     3d6:	c8 01       	movw	r24, r16
     3d8:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     3dc:	8c 89       	ldd	r24, Y+20	; 0x14
     3de:	9d 89       	ldd	r25, Y+21	; 0x15
     3e0:	00 97       	sbiw	r24, 0x00	; 0
     3e2:	21 f0       	breq	.+8      	; 0x3ec <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     3e4:	ce 01       	movw	r24, r28
     3e6:	0c 96       	adiw	r24, 0x0c	; 12
     3e8:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
     3ec:	8a e4       	ldi	r24, 0x4A	; 74
     3ee:	91 e0       	ldi	r25, 0x01	; 1
     3f0:	b8 01       	movw	r22, r16
     3f2:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
     3f6:	80 91 53 01 	lds	r24, 0x0153
     3fa:	8f 5f       	subi	r24, 0xFF	; 255
     3fc:	80 93 53 01 	sts	0x0153, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
     400:	80 91 54 01 	lds	r24, 0x0154
     404:	8f 5f       	subi	r24, 0xFF	; 255
     406:	80 93 54 01 	sts	0x0154, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     40a:	0f 90       	pop	r0
     40c:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
     40e:	80 91 49 01 	lds	r24, 0x0149
     412:	88 23       	and	r24, r24
     414:	49 f0       	breq	.+18     	; 0x428 <vTaskDelete+0x76>
		{
			if( pxTCB == pxCurrentTCB )
     416:	80 91 0e 01 	lds	r24, 0x010E
     41a:	90 91 0f 01 	lds	r25, 0x010F
     41e:	c8 17       	cp	r28, r24
     420:	d9 07       	cpc	r29, r25
     422:	11 f4       	brne	.+4      	; 0x428 <vTaskDelete+0x76>
			{
				portYIELD_WITHIN_API();
     424:	0e 94 ce 0c 	call	0x199c	; 0x199c <vPortYield>
			}
		}
	}
     428:	df 91       	pop	r29
     42a:	cf 91       	pop	r28
     42c:	1f 91       	pop	r17
     42e:	0f 91       	pop	r16
     430:	08 95       	ret

00000432 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     432:	af 92       	push	r10
     434:	bf 92       	push	r11
     436:	cf 92       	push	r12
     438:	df 92       	push	r13
     43a:	ef 92       	push	r14
     43c:	ff 92       	push	r15
     43e:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     440:	8a eb       	ldi	r24, 0xBA	; 186
     442:	93 e0       	ldi	r25, 0x03	; 3
     444:	66 e0       	ldi	r22, 0x06	; 6
     446:	71 e0       	ldi	r23, 0x01	; 1
     448:	45 e5       	ldi	r20, 0x55	; 85
     44a:	50 e0       	ldi	r21, 0x00	; 0
     44c:	20 e0       	ldi	r18, 0x00	; 0
     44e:	30 e0       	ldi	r19, 0x00	; 0
     450:	00 e0       	ldi	r16, 0x00	; 0
     452:	ee 24       	eor	r14, r14
     454:	ff 24       	eor	r15, r15
     456:	cc 24       	eor	r12, r12
     458:	dd 24       	eor	r13, r13
     45a:	aa 24       	eor	r10, r10
     45c:	bb 24       	eor	r11, r11
     45e:	0e 94 c5 00 	call	0x18a	; 0x18a <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     462:	81 30       	cpi	r24, 0x01	; 1
     464:	49 f4       	brne	.+18     	; 0x478 <vTaskStartScheduler+0x46>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     466:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
     468:	80 93 49 01 	sts	0x0149, r24
		xTickCount = ( portTickType ) 0U;
     46c:	10 92 12 01 	sts	0x0112, r1
     470:	10 92 11 01 	sts	0x0111, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     474:	0e 94 8d 0c 	call	0x191a	; 0x191a <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     478:	0f 91       	pop	r16
     47a:	ff 90       	pop	r15
     47c:	ef 90       	pop	r14
     47e:	df 90       	pop	r13
     480:	cf 90       	pop	r12
     482:	bf 90       	pop	r11
     484:	af 90       	pop	r10
     486:	08 95       	ret

00000488 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     488:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     48a:	10 92 49 01 	sts	0x0149, r1
	vPortEndScheduler();
     48e:	0e 94 cd 0c 	call	0x199a	; 0x199a <vPortEndScheduler>
}
     492:	08 95       	ret

00000494 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     494:	80 91 14 01 	lds	r24, 0x0114
     498:	8f 5f       	subi	r24, 0xFF	; 255
     49a:	80 93 14 01 	sts	0x0114, r24
}
     49e:	08 95       	ret

000004a0 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     4a0:	0f b6       	in	r0, 0x3f	; 63
     4a2:	f8 94       	cli
     4a4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     4a6:	20 91 11 01 	lds	r18, 0x0111
     4aa:	30 91 12 01 	lds	r19, 0x0112
	}
	taskEXIT_CRITICAL();
     4ae:	0f 90       	pop	r0
     4b0:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     4b2:	c9 01       	movw	r24, r18
     4b4:	08 95       	ret

000004b6 <xTaskGetTickCountFromISR>:
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
     4b6:	20 91 11 01 	lds	r18, 0x0111
     4ba:	30 91 12 01 	lds	r19, 0x0112
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     4be:	c9 01       	movw	r24, r18
     4c0:	08 95       	ret

000004c2 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     4c2:	80 91 48 01 	lds	r24, 0x0148
}
     4c6:	08 95       	ret

000004c8 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

portBASE_TYPE xTaskIncrementTick( void )
{
     4c8:	cf 92       	push	r12
     4ca:	df 92       	push	r13
     4cc:	ef 92       	push	r14
     4ce:	ff 92       	push	r15
     4d0:	0f 93       	push	r16
     4d2:	1f 93       	push	r17
     4d4:	df 93       	push	r29
     4d6:	cf 93       	push	r28
     4d8:	0f 92       	push	r0
     4da:	cd b7       	in	r28, 0x3d	; 61
     4dc:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     4de:	80 91 14 01 	lds	r24, 0x0114
     4e2:	88 23       	and	r24, r24
     4e4:	09 f0       	breq	.+2      	; 0x4e8 <xTaskIncrementTick+0x20>
     4e6:	bb c0       	rjmp	.+374    	; 0x65e <xTaskIncrementTick+0x196>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     4e8:	80 91 11 01 	lds	r24, 0x0111
     4ec:	90 91 12 01 	lds	r25, 0x0112
     4f0:	01 96       	adiw	r24, 0x01	; 1
     4f2:	90 93 12 01 	sts	0x0112, r25
     4f6:	80 93 11 01 	sts	0x0111, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
     4fa:	00 91 11 01 	lds	r16, 0x0111
     4fe:	10 91 12 01 	lds	r17, 0x0112

			if( xConstTickCount == ( portTickType ) 0U )
     502:	01 15       	cp	r16, r1
     504:	11 05       	cpc	r17, r1
     506:	79 f5       	brne	.+94     	; 0x566 <xTaskIncrementTick+0x9e>
			{
				taskSWITCH_DELAYED_LISTS();
     508:	80 91 45 01 	lds	r24, 0x0145
     50c:	90 91 46 01 	lds	r25, 0x0146
     510:	20 91 43 01 	lds	r18, 0x0143
     514:	30 91 44 01 	lds	r19, 0x0144
     518:	30 93 46 01 	sts	0x0146, r19
     51c:	20 93 45 01 	sts	0x0145, r18
     520:	90 93 44 01 	sts	0x0144, r25
     524:	80 93 43 01 	sts	0x0143, r24
     528:	80 91 13 01 	lds	r24, 0x0113
     52c:	8f 5f       	subi	r24, 0xFF	; 255
     52e:	80 93 13 01 	sts	0x0113, r24
     532:	e0 91 45 01 	lds	r30, 0x0145
     536:	f0 91 46 01 	lds	r31, 0x0146
     53a:	80 81       	ld	r24, Z
     53c:	88 23       	and	r24, r24
     53e:	19 f4       	brne	.+6      	; 0x546 <xTaskIncrementTick+0x7e>
     540:	8f ef       	ldi	r24, 0xFF	; 255
     542:	9f ef       	ldi	r25, 0xFF	; 255
     544:	0c c0       	rjmp	.+24     	; 0x55e <xTaskIncrementTick+0x96>
     546:	e0 91 45 01 	lds	r30, 0x0145
     54a:	f0 91 46 01 	lds	r31, 0x0146
     54e:	05 80       	ldd	r0, Z+5	; 0x05
     550:	f6 81       	ldd	r31, Z+6	; 0x06
     552:	e0 2d       	mov	r30, r0
     554:	06 80       	ldd	r0, Z+6	; 0x06
     556:	f7 81       	ldd	r31, Z+7	; 0x07
     558:	e0 2d       	mov	r30, r0
     55a:	82 81       	ldd	r24, Z+2	; 0x02
     55c:	93 81       	ldd	r25, Z+3	; 0x03
     55e:	90 93 0c 01 	sts	0x010C, r25
     562:	80 93 0b 01 	sts	0x010B, r24

			/* See if this tick has made a timeout expire.  Tasks are stored in the
			queue in the order of their wake time - meaning once one tasks has been
			found whose block time has not expired there is no need not look any
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     566:	80 91 0b 01 	lds	r24, 0x010B
     56a:	90 91 0c 01 	lds	r25, 0x010C
     56e:	08 17       	cp	r16, r24
     570:	19 07       	cpc	r17, r25
     572:	08 f4       	brcc	.+2      	; 0x576 <xTaskIncrementTick+0xae>
     574:	5f c0       	rjmp	.+190    	; 0x634 <xTaskIncrementTick+0x16c>
     576:	40 e0       	ldi	r20, 0x00	; 0
     578:	01 c0       	rjmp	.+2      	; 0x57c <xTaskIncrementTick+0xb4>
							be performed if the unblocked task has a priority that
							is equal to or higher than the currently executing
							task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
     57a:	41 e0       	ldi	r20, 0x01	; 1
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     57c:	e0 91 45 01 	lds	r30, 0x0145
     580:	f0 91 46 01 	lds	r31, 0x0146
     584:	80 81       	ld	r24, Z
     586:	88 23       	and	r24, r24
     588:	19 f4       	brne	.+6      	; 0x590 <xTaskIncrementTick+0xc8>
					{
						/* The delayed list is empty.  Set xNextTaskUnblockTime to
						the	maximum possible value so it is extremely unlikely that
						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     58a:	8f ef       	ldi	r24, 0xFF	; 255
     58c:	9f ef       	ldi	r25, 0xFF	; 255
     58e:	11 c0       	rjmp	.+34     	; 0x5b2 <xTaskIncrementTick+0xea>
					{
						/* The delayed list is not empty, get the value of the item
						at the head of the delayed list.  This is the time at which
						the task at the head of the delayed list must be removed
						from the Blocked state. */
						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     590:	e0 91 45 01 	lds	r30, 0x0145
     594:	f0 91 46 01 	lds	r31, 0x0146
     598:	05 80       	ldd	r0, Z+5	; 0x05
     59a:	f6 81       	ldd	r31, Z+6	; 0x06
     59c:	e0 2d       	mov	r30, r0
     59e:	c6 80       	ldd	r12, Z+6	; 0x06
     5a0:	d7 80       	ldd	r13, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     5a2:	d6 01       	movw	r26, r12
     5a4:	12 96       	adiw	r26, 0x02	; 2
     5a6:	8d 91       	ld	r24, X+
     5a8:	9c 91       	ld	r25, X
     5aa:	13 97       	sbiw	r26, 0x03	; 3

						if( xConstTickCount < xItemValue )
     5ac:	08 17       	cp	r16, r24
     5ae:	19 07       	cpc	r17, r25
     5b0:	28 f4       	brcc	.+10     	; 0x5bc <xTaskIncrementTick+0xf4>
						{
							/* It is not time to unblock this item yet, but the item
							value is the time at which the task at the head of the
							blocked list must be removed from the Blocked state -
							so record the item value in xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     5b2:	90 93 0c 01 	sts	0x010C, r25
     5b6:	80 93 0b 01 	sts	0x010B, r24
							break;
     5ba:	3d c0       	rjmp	.+122    	; 0x636 <xTaskIncrementTick+0x16e>
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     5bc:	82 e0       	ldi	r24, 0x02	; 2
     5be:	e8 2e       	mov	r14, r24
     5c0:	f1 2c       	mov	r15, r1
     5c2:	ec 0c       	add	r14, r12
     5c4:	fd 1c       	adc	r15, r13
     5c6:	c7 01       	movw	r24, r14
     5c8:	49 83       	std	Y+1, r20	; 0x01
     5ca:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove it
						from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     5ce:	f6 01       	movw	r30, r12
     5d0:	84 89       	ldd	r24, Z+20	; 0x14
     5d2:	95 89       	ldd	r25, Z+21	; 0x15
     5d4:	49 81       	ldd	r20, Y+1	; 0x01
     5d6:	00 97       	sbiw	r24, 0x00	; 0
     5d8:	29 f0       	breq	.+10     	; 0x5e4 <xTaskIncrementTick+0x11c>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     5da:	c6 01       	movw	r24, r12
     5dc:	0c 96       	adiw	r24, 0x0c	; 12
     5de:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
     5e2:	49 81       	ldd	r20, Y+1	; 0x01
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     5e4:	d6 01       	movw	r26, r12
     5e6:	56 96       	adiw	r26, 0x16	; 22
     5e8:	8c 91       	ld	r24, X
     5ea:	56 97       	sbiw	r26, 0x16	; 22
     5ec:	90 91 15 01 	lds	r25, 0x0115
     5f0:	98 17       	cp	r25, r24
     5f2:	10 f4       	brcc	.+4      	; 0x5f8 <xTaskIncrementTick+0x130>
     5f4:	80 93 15 01 	sts	0x0115, r24
     5f8:	90 e0       	ldi	r25, 0x00	; 0
     5fa:	9c 01       	movw	r18, r24
     5fc:	b3 e0       	ldi	r27, 0x03	; 3
     5fe:	22 0f       	add	r18, r18
     600:	33 1f       	adc	r19, r19
     602:	ba 95       	dec	r27
     604:	e1 f7       	brne	.-8      	; 0x5fe <xTaskIncrementTick+0x136>
     606:	28 0f       	add	r18, r24
     608:	39 1f       	adc	r19, r25
     60a:	c9 01       	movw	r24, r18
     60c:	8a 5e       	subi	r24, 0xEA	; 234
     60e:	9e 4f       	sbci	r25, 0xFE	; 254
     610:	b7 01       	movw	r22, r14
     612:	49 83       	std	Y+1, r20	; 0x01
     614:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should only
							be performed if the unblocked task has a priority that
							is equal to or higher than the currently executing
							task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     618:	e0 91 0e 01 	lds	r30, 0x010E
     61c:	f0 91 0f 01 	lds	r31, 0x010F
     620:	d6 01       	movw	r26, r12
     622:	56 96       	adiw	r26, 0x16	; 22
     624:	9c 91       	ld	r25, X
     626:	56 97       	sbiw	r26, 0x16	; 22
     628:	86 89       	ldd	r24, Z+22	; 0x16
     62a:	49 81       	ldd	r20, Y+1	; 0x01
     62c:	98 17       	cp	r25, r24
     62e:	08 f0       	brcs	.+2      	; 0x632 <xTaskIncrementTick+0x16a>
     630:	a4 cf       	rjmp	.-184    	; 0x57a <xTaskIncrementTick+0xb2>
     632:	a4 cf       	rjmp	.-184    	; 0x57c <xTaskIncrementTick+0xb4>

portBASE_TYPE xTaskIncrementTick( void )
{
tskTCB * pxTCB;
portTickType xItemValue;
portBASE_TYPE xSwitchRequired = pdFALSE;
     634:	40 e0       	ldi	r20, 0x00	; 0
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
     636:	e0 91 0e 01 	lds	r30, 0x010E
     63a:	f0 91 0f 01 	lds	r31, 0x010F
     63e:	86 89       	ldd	r24, Z+22	; 0x16
     640:	90 e0       	ldi	r25, 0x00	; 0
     642:	fc 01       	movw	r30, r24
     644:	a3 e0       	ldi	r26, 0x03	; 3
     646:	ee 0f       	add	r30, r30
     648:	ff 1f       	adc	r31, r31
     64a:	aa 95       	dec	r26
     64c:	e1 f7       	brne	.-8      	; 0x646 <xTaskIncrementTick+0x17e>
     64e:	e8 0f       	add	r30, r24
     650:	f9 1f       	adc	r31, r25
     652:	ea 5e       	subi	r30, 0xEA	; 234
     654:	fe 4f       	sbci	r31, 0xFE	; 254
     656:	80 81       	ld	r24, Z
     658:	82 30       	cpi	r24, 0x02	; 2
     65a:	40 f4       	brcc	.+16     	; 0x66c <xTaskIncrementTick+0x1a4>
     65c:	08 c0       	rjmp	.+16     	; 0x66e <xTaskIncrementTick+0x1a6>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     65e:	80 91 47 01 	lds	r24, 0x0147
     662:	8f 5f       	subi	r24, 0xFF	; 255
     664:	80 93 47 01 	sts	0x0147, r24

portBASE_TYPE xTaskIncrementTick( void )
{
tskTCB * pxTCB;
portTickType xItemValue;
portBASE_TYPE xSwitchRequired = pdFALSE;
     668:	40 e0       	ldi	r20, 0x00	; 0
     66a:	01 c0       	rjmp	.+2      	; 0x66e <xTaskIncrementTick+0x1a6>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
			{
				xSwitchRequired = pdTRUE;
     66c:	41 e0       	ldi	r20, 0x01	; 1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     66e:	80 91 10 01 	lds	r24, 0x0110
     672:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     674:	41 e0       	ldi	r20, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     676:	84 2f       	mov	r24, r20
     678:	0f 90       	pop	r0
     67a:	cf 91       	pop	r28
     67c:	df 91       	pop	r29
     67e:	1f 91       	pop	r17
     680:	0f 91       	pop	r16
     682:	ff 90       	pop	r15
     684:	ef 90       	pop	r14
     686:	df 90       	pop	r13
     688:	cf 90       	pop	r12
     68a:	08 95       	ret

0000068c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     68c:	ff 92       	push	r15
     68e:	0f 93       	push	r16
     690:	1f 93       	push	r17
     692:	cf 93       	push	r28
     694:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     696:	0f b6       	in	r0, 0x3f	; 63
     698:	f8 94       	cli
     69a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     69c:	80 91 14 01 	lds	r24, 0x0114
     6a0:	81 50       	subi	r24, 0x01	; 1
     6a2:	80 93 14 01 	sts	0x0114, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     6a6:	80 91 14 01 	lds	r24, 0x0114
     6aa:	88 23       	and	r24, r24
     6ac:	09 f0       	breq	.+2      	; 0x6b0 <xTaskResumeAll+0x24>
     6ae:	59 c0       	rjmp	.+178    	; 0x762 <xTaskResumeAll+0xd6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     6b0:	80 91 48 01 	lds	r24, 0x0148
     6b4:	88 23       	and	r24, r24
     6b6:	89 f5       	brne	.+98     	; 0x71a <xTaskResumeAll+0x8e>
     6b8:	55 c0       	rjmp	.+170    	; 0x764 <xTaskResumeAll+0xd8>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     6ba:	e0 91 3f 01 	lds	r30, 0x013F
     6be:	f0 91 40 01 	lds	r31, 0x0140
     6c2:	c6 81       	ldd	r28, Z+6	; 0x06
     6c4:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     6c6:	ce 01       	movw	r24, r28
     6c8:	0c 96       	adiw	r24, 0x0c	; 12
     6ca:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     6ce:	8e 01       	movw	r16, r28
     6d0:	0e 5f       	subi	r16, 0xFE	; 254
     6d2:	1f 4f       	sbci	r17, 0xFF	; 255
     6d4:	c8 01       	movw	r24, r16
     6d6:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     6da:	2e 89       	ldd	r18, Y+22	; 0x16
     6dc:	80 91 15 01 	lds	r24, 0x0115
     6e0:	82 17       	cp	r24, r18
     6e2:	10 f4       	brcc	.+4      	; 0x6e8 <xTaskResumeAll+0x5c>
     6e4:	20 93 15 01 	sts	0x0115, r18
     6e8:	30 e0       	ldi	r19, 0x00	; 0
     6ea:	c9 01       	movw	r24, r18
     6ec:	43 e0       	ldi	r20, 0x03	; 3
     6ee:	88 0f       	add	r24, r24
     6f0:	99 1f       	adc	r25, r25
     6f2:	4a 95       	dec	r20
     6f4:	e1 f7       	brne	.-8      	; 0x6ee <xTaskResumeAll+0x62>
     6f6:	82 0f       	add	r24, r18
     6f8:	93 1f       	adc	r25, r19
     6fa:	8a 5e       	subi	r24, 0xEA	; 234
     6fc:	9e 4f       	sbci	r25, 0xFE	; 254
     6fe:	b8 01       	movw	r22, r16
     700:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     704:	e0 91 0e 01 	lds	r30, 0x010E
     708:	f0 91 0f 01 	lds	r31, 0x010F
     70c:	9e 89       	ldd	r25, Y+22	; 0x16
     70e:	86 89       	ldd	r24, Z+22	; 0x16
     710:	98 17       	cp	r25, r24
     712:	28 f0       	brcs	.+10     	; 0x71e <xTaskResumeAll+0x92>
					{
						xYieldPending = pdTRUE;
     714:	f0 92 10 01 	sts	0x0110, r15
     718:	02 c0       	rjmp	.+4      	; 0x71e <xTaskResumeAll+0x92>
     71a:	ff 24       	eor	r15, r15
     71c:	f3 94       	inc	r15
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     71e:	80 91 3a 01 	lds	r24, 0x013A
     722:	88 23       	and	r24, r24
     724:	51 f6       	brne	.-108    	; 0x6ba <xTaskResumeAll+0x2e>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
     726:	80 91 47 01 	lds	r24, 0x0147
     72a:	88 23       	and	r24, r24
     72c:	69 f4       	brne	.+26     	; 0x748 <xTaskResumeAll+0xbc>
     72e:	11 c0       	rjmp	.+34     	; 0x752 <xTaskResumeAll+0xc6>
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
     730:	0e 94 64 02 	call	0x4c8	; 0x4c8 <xTaskIncrementTick>
     734:	88 23       	and	r24, r24
     736:	11 f0       	breq	.+4      	; 0x73c <xTaskResumeAll+0xb0>
						{
							xYieldPending = pdTRUE;
     738:	00 93 10 01 	sts	0x0110, r16
						}
						--uxPendedTicks;
     73c:	80 91 47 01 	lds	r24, 0x0147
     740:	81 50       	subi	r24, 0x01	; 1
     742:	80 93 47 01 	sts	0x0147, r24
     746:	01 c0       	rjmp	.+2      	; 0x74a <xTaskResumeAll+0xbe>
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
     748:	01 e0       	ldi	r16, 0x01	; 1
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
     74a:	80 91 47 01 	lds	r24, 0x0147
     74e:	88 23       	and	r24, r24
     750:	79 f7       	brne	.-34     	; 0x730 <xTaskResumeAll+0xa4>
						}
						--uxPendedTicks;
					}
				}

				if( xYieldPending == pdTRUE )
     752:	80 91 10 01 	lds	r24, 0x0110
     756:	81 30       	cpi	r24, 0x01	; 1
     758:	21 f4       	brne	.+8      	; 0x762 <xTaskResumeAll+0xd6>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     75a:	0e 94 ce 0c 	call	0x199c	; 0x199c <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     75e:	81 e0       	ldi	r24, 0x01	; 1
     760:	01 c0       	rjmp	.+2      	; 0x764 <xTaskResumeAll+0xd8>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
tskTCB *pxTCB;
portBASE_TYPE xAlreadyYielded = pdFALSE;
     762:	80 e0       	ldi	r24, 0x00	; 0
					taskYIELD_IF_USING_PREEMPTION();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     764:	0f 90       	pop	r0
     766:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     768:	df 91       	pop	r29
     76a:	cf 91       	pop	r28
     76c:	1f 91       	pop	r17
     76e:	0f 91       	pop	r16
     770:	ff 90       	pop	r15
     772:	08 95       	ret

00000774 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
     774:	1f 93       	push	r17
     776:	cf 93       	push	r28
     778:	df 93       	push	r29
     77a:	28 c0       	rjmp	.+80     	; 0x7cc <prvIdleTask+0x58>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
     77c:	0e 94 4a 02 	call	0x494	; 0x494 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     780:	10 91 4a 01 	lds	r17, 0x014A
			( void ) xTaskResumeAll();
     784:	0e 94 46 03 	call	0x68c	; 0x68c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     788:	11 23       	and	r17, r17
     78a:	01 f1       	breq	.+64     	; 0x7cc <prvIdleTask+0x58>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
     78c:	0f b6       	in	r0, 0x3f	; 63
     78e:	f8 94       	cli
     790:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     792:	e0 91 4f 01 	lds	r30, 0x014F
     796:	f0 91 50 01 	lds	r31, 0x0150
     79a:	c6 81       	ldd	r28, Z+6	; 0x06
     79c:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     79e:	ce 01       	movw	r24, r28
     7a0:	02 96       	adiw	r24, 0x02	; 2
     7a2:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
					--uxCurrentNumberOfTasks;
     7a6:	80 91 48 01 	lds	r24, 0x0148
     7aa:	81 50       	subi	r24, 0x01	; 1
     7ac:	80 93 48 01 	sts	0x0148, r24
					--uxTasksDeleted;
     7b0:	80 91 53 01 	lds	r24, 0x0153
     7b4:	81 50       	subi	r24, 0x01	; 1
     7b6:	80 93 53 01 	sts	0x0153, r24
				}
				taskEXIT_CRITICAL();
     7ba:	0f 90       	pop	r0
     7bc:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
     7be:	8f 89       	ldd	r24, Y+23	; 0x17
     7c0:	98 8d       	ldd	r25, Y+24	; 0x18
     7c2:	0e 94 33 0c 	call	0x1866	; 0x1866 <vPortFree>
		vPortFree( pxTCB );
     7c6:	ce 01       	movw	r24, r28
     7c8:	0e 94 33 0c 	call	0x1866	; 0x1866 <vPortFree>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
     7cc:	80 91 53 01 	lds	r24, 0x0153
     7d0:	88 23       	and	r24, r24
     7d2:	a1 f6       	brne	.-88     	; 0x77c <prvIdleTask+0x8>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
     7d4:	80 91 16 01 	lds	r24, 0x0116
     7d8:	82 30       	cpi	r24, 0x02	; 2
     7da:	10 f0       	brcs	.+4      	; 0x7e0 <prvIdleTask+0x6c>
			{
				taskYIELD();
     7dc:	0e 94 ce 0c 	call	0x199c	; 0x199c <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     7e0:	0e 94 8d 00 	call	0x11a	; 0x11a <vApplicationIdleHook>
     7e4:	f3 cf       	rjmp	.-26     	; 0x7cc <prvIdleTask+0x58>

000007e6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     7e6:	0f 93       	push	r16
     7e8:	1f 93       	push	r17
     7ea:	cf 93       	push	r28
     7ec:	df 93       	push	r29
     7ee:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     7f0:	00 97       	sbiw	r24, 0x00	; 0
     7f2:	b1 f0       	breq	.+44     	; 0x820 <vTaskDelay+0x3a>
		{
			vTaskSuspendAll();
     7f4:	0e 94 4a 02 	call	0x494	; 0x494 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     7f8:	00 91 11 01 	lds	r16, 0x0111
     7fc:	10 91 12 01 	lds	r17, 0x0112

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
     800:	80 91 0e 01 	lds	r24, 0x010E
     804:	90 91 0f 01 	lds	r25, 0x010F
     808:	02 96       	adiw	r24, 0x02	; 2
     80a:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     80e:	ce 01       	movw	r24, r28
     810:	80 0f       	add	r24, r16
     812:	91 1f       	adc	r25, r17
     814:	0e 94 8e 00 	call	0x11c	; 0x11c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     818:	0e 94 46 03 	call	0x68c	; 0x68c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     81c:	88 23       	and	r24, r24
     81e:	11 f4       	brne	.+4      	; 0x824 <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
     820:	0e 94 ce 0c 	call	0x199c	; 0x199c <vPortYield>
		}
	}
     824:	df 91       	pop	r29
     826:	cf 91       	pop	r28
     828:	1f 91       	pop	r17
     82a:	0f 91       	pop	r16
     82c:	08 95       	ret

0000082e <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     82e:	0f 93       	push	r16
     830:	1f 93       	push	r17
     832:	cf 93       	push	r28
     834:	df 93       	push	r29
     836:	8c 01       	movw	r16, r24
     838:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
     83a:	0e 94 4a 02 	call	0x494	; 0x494 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
     83e:	20 91 11 01 	lds	r18, 0x0111
     842:	30 91 12 01 	lds	r19, 0x0112

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     846:	f8 01       	movw	r30, r16
     848:	80 81       	ld	r24, Z
     84a:	91 81       	ldd	r25, Z+1	; 0x01
     84c:	c8 0f       	add	r28, r24
     84e:	d9 1f       	adc	r29, r25

			if( xConstTickCount < *pxPreviousWakeTime )
     850:	28 17       	cp	r18, r24
     852:	39 07       	cpc	r19, r25
     854:	20 f4       	brcc	.+8      	; 0x85e <vTaskDelayUntil+0x30>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     856:	c8 17       	cp	r28, r24
     858:	d9 07       	cpc	r29, r25
     85a:	40 f4       	brcc	.+16     	; 0x86c <vTaskDelayUntil+0x3e>
     85c:	03 c0       	rjmp	.+6      	; 0x864 <vTaskDelayUntil+0x36>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     85e:	c8 17       	cp	r28, r24
     860:	d9 07       	cpc	r29, r25
     862:	30 f0       	brcs	.+12     	; 0x870 <vTaskDelayUntil+0x42>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
     864:	81 e0       	ldi	r24, 0x01	; 1
     866:	2c 17       	cp	r18, r28
     868:	3d 07       	cpc	r19, r29
     86a:	18 f0       	brcs	.+6      	; 0x872 <vTaskDelayUntil+0x44>
     86c:	80 e0       	ldi	r24, 0x00	; 0
     86e:	01 c0       	rjmp	.+2      	; 0x872 <vTaskDelayUntil+0x44>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     870:	81 e0       	ldi	r24, 0x01	; 1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     872:	f8 01       	movw	r30, r16
     874:	d1 83       	std	Z+1, r29	; 0x01
     876:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
     878:	88 23       	and	r24, r24
     87a:	51 f0       	breq	.+20     	; 0x890 <vTaskDelayUntil+0x62>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
     87c:	80 91 0e 01 	lds	r24, 0x010E
     880:	90 91 0f 01 	lds	r25, 0x010F
     884:	02 96       	adiw	r24, 0x02	; 2
     886:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     88a:	ce 01       	movw	r24, r28
     88c:	0e 94 8e 00 	call	0x11c	; 0x11c <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     890:	0e 94 46 03 	call	0x68c	; 0x68c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     894:	88 23       	and	r24, r24
     896:	11 f4       	brne	.+4      	; 0x89c <vTaskDelayUntil+0x6e>
		{
			portYIELD_WITHIN_API();
     898:	0e 94 ce 0c 	call	0x199c	; 0x199c <vPortYield>
		}
	}
     89c:	df 91       	pop	r29
     89e:	cf 91       	pop	r28
     8a0:	1f 91       	pop	r17
     8a2:	0f 91       	pop	r16
     8a4:	08 95       	ret

000008a6 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     8a6:	80 91 14 01 	lds	r24, 0x0114
     8aa:	88 23       	and	r24, r24
     8ac:	21 f0       	breq	.+8      	; 0x8b6 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     8ae:	81 e0       	ldi	r24, 0x01	; 1
     8b0:	80 93 10 01 	sts	0x0110, r24
     8b4:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     8b6:	10 92 10 01 	sts	0x0110, r1
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
     8ba:	05 c0       	rjmp	.+10     	; 0x8c6 <vTaskSwitchContext+0x20>
     8bc:	80 91 15 01 	lds	r24, 0x0115
     8c0:	81 50       	subi	r24, 0x01	; 1
     8c2:	80 93 15 01 	sts	0x0115, r24
     8c6:	80 91 15 01 	lds	r24, 0x0115
     8ca:	90 e0       	ldi	r25, 0x00	; 0
     8cc:	fc 01       	movw	r30, r24
     8ce:	73 e0       	ldi	r23, 0x03	; 3
     8d0:	ee 0f       	add	r30, r30
     8d2:	ff 1f       	adc	r31, r31
     8d4:	7a 95       	dec	r23
     8d6:	e1 f7       	brne	.-8      	; 0x8d0 <vTaskSwitchContext+0x2a>
     8d8:	e8 0f       	add	r30, r24
     8da:	f9 1f       	adc	r31, r25
     8dc:	ea 5e       	subi	r30, 0xEA	; 234
     8de:	fe 4f       	sbci	r31, 0xFE	; 254
     8e0:	80 81       	ld	r24, Z
     8e2:	88 23       	and	r24, r24
     8e4:	59 f3       	breq	.-42     	; 0x8bc <vTaskSwitchContext+0x16>
     8e6:	80 91 15 01 	lds	r24, 0x0115
     8ea:	90 e0       	ldi	r25, 0x00	; 0
     8ec:	9c 01       	movw	r18, r24
     8ee:	63 e0       	ldi	r22, 0x03	; 3
     8f0:	22 0f       	add	r18, r18
     8f2:	33 1f       	adc	r19, r19
     8f4:	6a 95       	dec	r22
     8f6:	e1 f7       	brne	.-8      	; 0x8f0 <vTaskSwitchContext+0x4a>
     8f8:	28 0f       	add	r18, r24
     8fa:	39 1f       	adc	r19, r25
     8fc:	f9 01       	movw	r30, r18
     8fe:	ea 5e       	subi	r30, 0xEA	; 234
     900:	fe 4f       	sbci	r31, 0xFE	; 254
     902:	a1 81       	ldd	r26, Z+1	; 0x01
     904:	b2 81       	ldd	r27, Z+2	; 0x02
     906:	12 96       	adiw	r26, 0x02	; 2
     908:	0d 90       	ld	r0, X+
     90a:	bc 91       	ld	r27, X
     90c:	a0 2d       	mov	r26, r0
     90e:	b2 83       	std	Z+2, r27	; 0x02
     910:	a1 83       	std	Z+1, r26	; 0x01
     912:	27 5e       	subi	r18, 0xE7	; 231
     914:	3e 4f       	sbci	r19, 0xFE	; 254
     916:	a2 17       	cp	r26, r18
     918:	b3 07       	cpc	r27, r19
     91a:	31 f4       	brne	.+12     	; 0x928 <__stack+0x29>
     91c:	12 96       	adiw	r26, 0x02	; 2
     91e:	2d 91       	ld	r18, X+
     920:	3c 91       	ld	r19, X
     922:	13 97       	sbiw	r26, 0x03	; 3
     924:	32 83       	std	Z+2, r19	; 0x02
     926:	21 83       	std	Z+1, r18	; 0x01
     928:	fc 01       	movw	r30, r24
     92a:	53 e0       	ldi	r21, 0x03	; 3
     92c:	ee 0f       	add	r30, r30
     92e:	ff 1f       	adc	r31, r31
     930:	5a 95       	dec	r21
     932:	e1 f7       	brne	.-8      	; 0x92c <__stack+0x2d>
     934:	e8 0f       	add	r30, r24
     936:	f9 1f       	adc	r31, r25
     938:	ea 5e       	subi	r30, 0xEA	; 234
     93a:	fe 4f       	sbci	r31, 0xFE	; 254
     93c:	01 80       	ldd	r0, Z+1	; 0x01
     93e:	f2 81       	ldd	r31, Z+2	; 0x02
     940:	e0 2d       	mov	r30, r0
     942:	86 81       	ldd	r24, Z+6	; 0x06
     944:	97 81       	ldd	r25, Z+7	; 0x07
     946:	90 93 0f 01 	sts	0x010F, r25
     94a:	80 93 0e 01 	sts	0x010E, r24
     94e:	08 95       	ret

00000950 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
{
     950:	cf 93       	push	r28
     952:	df 93       	push	r29
     954:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     956:	60 91 0e 01 	lds	r22, 0x010E
     95a:	70 91 0f 01 	lds	r23, 0x010F
     95e:	64 5f       	subi	r22, 0xF4	; 244
     960:	7f 4f       	sbci	r23, 0xFF	; 255
     962:	0e 94 c8 09 	call	0x1390	; 0x1390 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
     966:	80 91 0e 01 	lds	r24, 0x010E
     96a:	90 91 0f 01 	lds	r25, 0x010F
     96e:	02 96       	adiw	r24, 0x02	; 2
     970:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
	}
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
     974:	80 91 11 01 	lds	r24, 0x0111
     978:	90 91 12 01 	lds	r25, 0x0112
			prvAddCurrentTaskToDelayedList( xTimeToWake );
     97c:	8c 0f       	add	r24, r28
     97e:	9d 1f       	adc	r25, r29
     980:	0e 94 8e 00 	call	0x11c	; 0x11c <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     984:	df 91       	pop	r29
     986:	cf 91       	pop	r28
     988:	08 95       	ret

0000098a <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
     98a:	0f 93       	push	r16
     98c:	1f 93       	push	r17
     98e:	cf 93       	push	r28
     990:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     992:	dc 01       	movw	r26, r24
     994:	15 96       	adiw	r26, 0x05	; 5
     996:	ed 91       	ld	r30, X+
     998:	fc 91       	ld	r31, X
     99a:	16 97       	sbiw	r26, 0x06	; 6
     99c:	c6 81       	ldd	r28, Z+6	; 0x06
     99e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     9a0:	8e 01       	movw	r16, r28
     9a2:	04 5f       	subi	r16, 0xF4	; 244
     9a4:	1f 4f       	sbci	r17, 0xFF	; 255
     9a6:	c8 01       	movw	r24, r16
     9a8:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     9ac:	80 91 14 01 	lds	r24, 0x0114
     9b0:	88 23       	and	r24, r24
     9b2:	c9 f4       	brne	.+50     	; 0x9e6 <xTaskRemoveFromEventList+0x5c>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
     9b4:	8e 01       	movw	r16, r28
     9b6:	0e 5f       	subi	r16, 0xFE	; 254
     9b8:	1f 4f       	sbci	r17, 0xFF	; 255
     9ba:	c8 01       	movw	r24, r16
     9bc:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     9c0:	2e 89       	ldd	r18, Y+22	; 0x16
     9c2:	80 91 15 01 	lds	r24, 0x0115
     9c6:	82 17       	cp	r24, r18
     9c8:	10 f4       	brcc	.+4      	; 0x9ce <xTaskRemoveFromEventList+0x44>
     9ca:	20 93 15 01 	sts	0x0115, r18
     9ce:	30 e0       	ldi	r19, 0x00	; 0
     9d0:	c9 01       	movw	r24, r18
     9d2:	e3 e0       	ldi	r30, 0x03	; 3
     9d4:	88 0f       	add	r24, r24
     9d6:	99 1f       	adc	r25, r25
     9d8:	ea 95       	dec	r30
     9da:	e1 f7       	brne	.-8      	; 0x9d4 <xTaskRemoveFromEventList+0x4a>
     9dc:	82 0f       	add	r24, r18
     9de:	93 1f       	adc	r25, r19
     9e0:	8a 5e       	subi	r24, 0xEA	; 234
     9e2:	9e 4f       	sbci	r25, 0xFE	; 254
     9e4:	02 c0       	rjmp	.+4      	; 0x9ea <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     9e6:	8a e3       	ldi	r24, 0x3A	; 58
     9e8:	91 e0       	ldi	r25, 0x01	; 1
     9ea:	b8 01       	movw	r22, r16
     9ec:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
     9f0:	e0 91 0e 01 	lds	r30, 0x010E
     9f4:	f0 91 0f 01 	lds	r31, 0x010F
     9f8:	9e 89       	ldd	r25, Y+22	; 0x16
     9fa:	86 89       	ldd	r24, Z+22	; 0x16
     9fc:	98 17       	cp	r25, r24
     9fe:	20 f0       	brcs	.+8      	; 0xa08 <xTaskRemoveFromEventList+0x7e>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     a00:	81 e0       	ldi	r24, 0x01	; 1
     a02:	80 93 10 01 	sts	0x0110, r24
     a06:	01 c0       	rjmp	.+2      	; 0xa0a <xTaskRemoveFromEventList+0x80>
	}
	else
	{
		xReturn = pdFALSE;
     a08:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
     a0a:	df 91       	pop	r29
     a0c:	cf 91       	pop	r28
     a0e:	1f 91       	pop	r17
     a10:	0f 91       	pop	r16
     a12:	08 95       	ret

00000a14 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
     a14:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     a16:	80 91 13 01 	lds	r24, 0x0113
     a1a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     a1c:	80 91 11 01 	lds	r24, 0x0111
     a20:	90 91 12 01 	lds	r25, 0x0112
     a24:	92 83       	std	Z+2, r25	; 0x02
     a26:	81 83       	std	Z+1, r24	; 0x01
}
     a28:	08 95       	ret

00000a2a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
     a2a:	fc 01       	movw	r30, r24
     a2c:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     a2e:	0f b6       	in	r0, 0x3f	; 63
     a30:	f8 94       	cli
     a32:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const portTickType xConstTickCount = xTickCount;
     a34:	20 91 11 01 	lds	r18, 0x0111
     a38:	30 91 12 01 	lds	r19, 0x0112
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     a3c:	90 91 13 01 	lds	r25, 0x0113
     a40:	80 81       	ld	r24, Z
     a42:	98 17       	cp	r25, r24
     a44:	29 f0       	breq	.+10     	; 0xa50 <xTaskCheckForTimeOut+0x26>
     a46:	81 81       	ldd	r24, Z+1	; 0x01
     a48:	92 81       	ldd	r25, Z+2	; 0x02
     a4a:	28 17       	cp	r18, r24
     a4c:	39 07       	cpc	r19, r25
     a4e:	e8 f4       	brcc	.+58     	; 0xa8a <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
     a50:	81 81       	ldd	r24, Z+1	; 0x01
     a52:	92 81       	ldd	r25, Z+2	; 0x02
     a54:	4d 91       	ld	r20, X+
     a56:	5c 91       	ld	r21, X
     a58:	11 97       	sbiw	r26, 0x01	; 1
     a5a:	b9 01       	movw	r22, r18
     a5c:	68 1b       	sub	r22, r24
     a5e:	79 0b       	sbc	r23, r25
     a60:	64 17       	cp	r22, r20
     a62:	75 07       	cpc	r23, r21
     a64:	90 f4       	brcc	.+36     	; 0xa8a <xTaskCheckForTimeOut+0x60>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
     a66:	82 1b       	sub	r24, r18
     a68:	93 0b       	sbc	r25, r19
     a6a:	84 0f       	add	r24, r20
     a6c:	95 1f       	adc	r25, r21
     a6e:	11 96       	adiw	r26, 0x01	; 1
     a70:	9c 93       	st	X, r25
     a72:	8e 93       	st	-X, r24
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     a74:	80 91 13 01 	lds	r24, 0x0113
     a78:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     a7a:	80 91 11 01 	lds	r24, 0x0111
     a7e:	90 91 12 01 	lds	r25, 0x0112
     a82:	92 83       	std	Z+2, r25	; 0x02
     a84:	81 83       	std	Z+1, r24	; 0x01
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
     a86:	80 e0       	ldi	r24, 0x00	; 0
     a88:	01 c0       	rjmp	.+2      	; 0xa8c <xTaskCheckForTimeOut+0x62>
		}
		else
		{
			xReturn = pdTRUE;
     a8a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
     a8c:	0f 90       	pop	r0
     a8e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     a90:	08 95       	ret

00000a92 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     a92:	81 e0       	ldi	r24, 0x01	; 1
     a94:	80 93 10 01 	sts	0x0110, r24
}
     a98:	08 95       	ret

00000a9a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     a9a:	1f 93       	push	r17
     a9c:	cf 93       	push	r28
     a9e:	df 93       	push	r29
     aa0:	ec 01       	movw	r28, r24
     aa2:	14 2f       	mov	r17, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     aa4:	4c 8d       	ldd	r20, Y+28	; 0x1c
     aa6:	44 23       	and	r20, r20
     aa8:	d9 f1       	breq	.+118    	; 0xb20 <prvCopyDataToQueue+0x86>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     aaa:	11 23       	and	r17, r17
     aac:	b1 f4       	brne	.+44     	; 0xada <prvCopyDataToQueue+0x40>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     aae:	8c 81       	ldd	r24, Y+4	; 0x04
     ab0:	9d 81       	ldd	r25, Y+5	; 0x05
     ab2:	50 e0       	ldi	r21, 0x00	; 0
     ab4:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     ab8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     aba:	8c 81       	ldd	r24, Y+4	; 0x04
     abc:	9d 81       	ldd	r25, Y+5	; 0x05
     abe:	82 0f       	add	r24, r18
     ac0:	91 1d       	adc	r25, r1
     ac2:	9d 83       	std	Y+5, r25	; 0x05
     ac4:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     ac6:	2a 81       	ldd	r18, Y+2	; 0x02
     ac8:	3b 81       	ldd	r19, Y+3	; 0x03
     aca:	82 17       	cp	r24, r18
     acc:	93 07       	cpc	r25, r19
     ace:	40 f1       	brcs	.+80     	; 0xb20 <prvCopyDataToQueue+0x86>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     ad0:	88 81       	ld	r24, Y
     ad2:	99 81       	ldd	r25, Y+1	; 0x01
     ad4:	9d 83       	std	Y+5, r25	; 0x05
     ad6:	8c 83       	std	Y+4, r24	; 0x04
     ad8:	23 c0       	rjmp	.+70     	; 0xb20 <prvCopyDataToQueue+0x86>
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     ada:	8e 81       	ldd	r24, Y+6	; 0x06
     adc:	9f 81       	ldd	r25, Y+7	; 0x07
     ade:	50 e0       	ldi	r21, 0x00	; 0
     ae0:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     ae4:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ae6:	30 e0       	ldi	r19, 0x00	; 0
     ae8:	30 95       	com	r19
     aea:	21 95       	neg	r18
     aec:	3f 4f       	sbci	r19, 0xFF	; 255
     aee:	8e 81       	ldd	r24, Y+6	; 0x06
     af0:	9f 81       	ldd	r25, Y+7	; 0x07
     af2:	82 0f       	add	r24, r18
     af4:	93 1f       	adc	r25, r19
     af6:	9f 83       	std	Y+7, r25	; 0x07
     af8:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     afa:	48 81       	ld	r20, Y
     afc:	59 81       	ldd	r21, Y+1	; 0x01
     afe:	84 17       	cp	r24, r20
     b00:	95 07       	cpc	r25, r21
     b02:	30 f4       	brcc	.+12     	; 0xb10 <prvCopyDataToQueue+0x76>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     b04:	8a 81       	ldd	r24, Y+2	; 0x02
     b06:	9b 81       	ldd	r25, Y+3	; 0x03
     b08:	82 0f       	add	r24, r18
     b0a:	93 1f       	adc	r25, r19
     b0c:	9f 83       	std	Y+7, r25	; 0x07
     b0e:	8e 83       	std	Y+6, r24	; 0x06
		}

		if( xPosition == queueOVERWRITE )
     b10:	12 30       	cpi	r17, 0x02	; 2
     b12:	31 f4       	brne	.+12     	; 0xb20 <prvCopyDataToQueue+0x86>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     b14:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b16:	88 23       	and	r24, r24
     b18:	19 f0       	breq	.+6      	; 0xb20 <prvCopyDataToQueue+0x86>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     b1a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b1c:	81 50       	subi	r24, 0x01	; 1
     b1e:	8a 8f       	std	Y+26, r24	; 0x1a
			}
		}
	}

	++( pxQueue->uxMessagesWaiting );
     b20:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b22:	8f 5f       	subi	r24, 0xFF	; 255
     b24:	8a 8f       	std	Y+26, r24	; 0x1a
}
     b26:	df 91       	pop	r29
     b28:	cf 91       	pop	r28
     b2a:	1f 91       	pop	r17
     b2c:	08 95       	ret

00000b2e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
{
     b2e:	cf 93       	push	r28
     b30:	df 93       	push	r29
     b32:	fc 01       	movw	r30, r24
     b34:	cb 01       	movw	r24, r22
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     b36:	a0 81       	ld	r26, Z
     b38:	b1 81       	ldd	r27, Z+1	; 0x01
     b3a:	10 97       	sbiw	r26, 0x00	; 0
     b3c:	a9 f0       	breq	.+42     	; 0xb68 <prvCopyDataFromQueue+0x3a>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     b3e:	44 8d       	ldd	r20, Z+28	; 0x1c
     b40:	26 81       	ldd	r18, Z+6	; 0x06
     b42:	37 81       	ldd	r19, Z+7	; 0x07
     b44:	24 0f       	add	r18, r20
     b46:	31 1d       	adc	r19, r1
     b48:	37 83       	std	Z+7, r19	; 0x07
     b4a:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     b4c:	c2 81       	ldd	r28, Z+2	; 0x02
     b4e:	d3 81       	ldd	r29, Z+3	; 0x03
     b50:	2c 17       	cp	r18, r28
     b52:	3d 07       	cpc	r19, r29
     b54:	10 f0       	brcs	.+4      	; 0xb5a <prvCopyDataFromQueue+0x2c>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     b56:	b7 83       	std	Z+7, r27	; 0x07
     b58:	a6 83       	std	Z+6, r26	; 0x06
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     b5a:	36 81       	ldd	r19, Z+6	; 0x06
     b5c:	27 81       	ldd	r18, Z+7	; 0x07
     b5e:	63 2f       	mov	r22, r19
     b60:	72 2f       	mov	r23, r18
     b62:	50 e0       	ldi	r21, 0x00	; 0
     b64:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <memcpy>
	}
}
     b68:	df 91       	pop	r29
     b6a:	cf 91       	pop	r28
     b6c:	08 95       	ret

00000b6e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
     b6e:	0f 93       	push	r16
     b70:	1f 93       	push	r17
     b72:	cf 93       	push	r28
     b74:	df 93       	push	r29
     b76:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     b78:	0f b6       	in	r0, 0x3f	; 63
     b7a:	f8 94       	cli
     b7c:	0f 92       	push	r0
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b7e:	8c 01       	movw	r16, r24
     b80:	0f 5e       	subi	r16, 0xEF	; 239
     b82:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     b84:	0d c0       	rjmp	.+26     	; 0xba0 <prvUnlockQueue+0x32>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b86:	89 89       	ldd	r24, Y+17	; 0x11
     b88:	88 23       	and	r24, r24
     b8a:	69 f0       	breq	.+26     	; 0xba6 <prvUnlockQueue+0x38>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b8c:	c8 01       	movw	r24, r16
     b8e:	0e 94 c5 04 	call	0x98a	; 0x98a <xTaskRemoveFromEventList>
     b92:	88 23       	and	r24, r24
     b94:	11 f0       	breq	.+4      	; 0xb9a <prvUnlockQueue+0x2c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     b96:	0e 94 49 05 	call	0xa92	; 0xa92 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     b9a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b9c:	81 50       	subi	r24, 0x01	; 1
     b9e:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     ba0:	8e 8d       	ldd	r24, Y+30	; 0x1e
     ba2:	18 16       	cp	r1, r24
     ba4:	84 f3       	brlt	.-32     	; 0xb86 <prvUnlockQueue+0x18>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     ba6:	8f ef       	ldi	r24, 0xFF	; 255
     ba8:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     baa:	0f 90       	pop	r0
     bac:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     bae:	0f b6       	in	r0, 0x3f	; 63
     bb0:	f8 94       	cli
     bb2:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     bb4:	8e 01       	movw	r16, r28
     bb6:	08 5f       	subi	r16, 0xF8	; 248
     bb8:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     bba:	0d c0       	rjmp	.+26     	; 0xbd6 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     bbc:	88 85       	ldd	r24, Y+8	; 0x08
     bbe:	88 23       	and	r24, r24
     bc0:	69 f0       	breq	.+26     	; 0xbdc <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     bc2:	c8 01       	movw	r24, r16
     bc4:	0e 94 c5 04 	call	0x98a	; 0x98a <xTaskRemoveFromEventList>
     bc8:	88 23       	and	r24, r24
     bca:	11 f0       	breq	.+4      	; 0xbd0 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
     bcc:	0e 94 49 05 	call	0xa92	; 0xa92 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     bd0:	8d 8d       	ldd	r24, Y+29	; 0x1d
     bd2:	81 50       	subi	r24, 0x01	; 1
     bd4:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     bd6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     bd8:	18 16       	cp	r1, r24
     bda:	84 f3       	brlt	.-32     	; 0xbbc <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     bdc:	8f ef       	ldi	r24, 0xFF	; 255
     bde:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     be0:	0f 90       	pop	r0
     be2:	0f be       	out	0x3f, r0	; 63
}
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
     be8:	1f 91       	pop	r17
     bea:	0f 91       	pop	r16
     bec:	08 95       	ret

00000bee <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
     bee:	ef 92       	push	r14
     bf0:	ff 92       	push	r15
     bf2:	cf 93       	push	r28
     bf4:	df 93       	push	r29
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
     bf6:	e8 2e       	mov	r14, r24
     bf8:	e7 01       	movw	r28, r14
     bfa:	7e 01       	movw	r14, r28
     bfc:	f9 2e       	mov	r15, r25
     bfe:	e7 01       	movw	r28, r14

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     c00:	0f b6       	in	r0, 0x3f	; 63
     c02:	f8 94       	cli
     c04:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     c06:	28 81       	ld	r18, Y
     c08:	39 81       	ldd	r19, Y+1	; 0x01
     c0a:	eb 8d       	ldd	r30, Y+27	; 0x1b
     c0c:	f0 e0       	ldi	r31, 0x00	; 0
     c0e:	4c 8d       	ldd	r20, Y+28	; 0x1c
     c10:	50 e0       	ldi	r21, 0x00	; 0
     c12:	4e 9f       	mul	r20, r30
     c14:	c0 01       	movw	r24, r0
     c16:	4f 9f       	mul	r20, r31
     c18:	90 0d       	add	r25, r0
     c1a:	5e 9f       	mul	r21, r30
     c1c:	90 0d       	add	r25, r0
     c1e:	11 24       	eor	r1, r1
     c20:	82 0f       	add	r24, r18
     c22:	93 1f       	adc	r25, r19
     c24:	9b 83       	std	Y+3, r25	; 0x03
     c26:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     c28:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     c2a:	3d 83       	std	Y+5, r19	; 0x05
     c2c:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
     c2e:	31 97       	sbiw	r30, 0x01	; 1
     c30:	e4 9f       	mul	r30, r20
     c32:	c0 01       	movw	r24, r0
     c34:	e5 9f       	mul	r30, r21
     c36:	90 0d       	add	r25, r0
     c38:	f4 9f       	mul	r31, r20
     c3a:	90 0d       	add	r25, r0
     c3c:	11 24       	eor	r1, r1
     c3e:	82 0f       	add	r24, r18
     c40:	93 1f       	adc	r25, r19
     c42:	9f 83       	std	Y+7, r25	; 0x07
     c44:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     c46:	8f ef       	ldi	r24, 0xFF	; 255
     c48:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     c4a:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     c4c:	66 23       	and	r22, r22
     c4e:	61 f4       	brne	.+24     	; 0xc68 <xQueueGenericReset+0x7a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c50:	88 85       	ldd	r24, Y+8	; 0x08
     c52:	88 23       	and	r24, r24
     c54:	89 f0       	breq	.+34     	; 0xc78 <xQueueGenericReset+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     c56:	c7 01       	movw	r24, r14
     c58:	08 96       	adiw	r24, 0x08	; 8
     c5a:	0e 94 c5 04 	call	0x98a	; 0x98a <xTaskRemoveFromEventList>
     c5e:	81 30       	cpi	r24, 0x01	; 1
     c60:	59 f4       	brne	.+22     	; 0xc78 <xQueueGenericReset+0x8a>
				{
					queueYIELD_IF_USING_PREEMPTION();
     c62:	0e 94 ce 0c 	call	0x199c	; 0x199c <vPortYield>
     c66:	08 c0       	rjmp	.+16     	; 0xc78 <xQueueGenericReset+0x8a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     c68:	c7 01       	movw	r24, r14
     c6a:	08 96       	adiw	r24, 0x08	; 8
     c6c:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     c70:	c7 01       	movw	r24, r14
     c72:	41 96       	adiw	r24, 0x11	; 17
     c74:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     c78:	0f 90       	pop	r0
     c7a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     c7c:	81 e0       	ldi	r24, 0x01	; 1
     c7e:	df 91       	pop	r29
     c80:	cf 91       	pop	r28
     c82:	ff 90       	pop	r15
     c84:	ef 90       	pop	r14
     c86:	08 95       	ret

00000c88 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
     c88:	ef 92       	push	r14
     c8a:	ff 92       	push	r15
     c8c:	0f 93       	push	r16
     c8e:	1f 93       	push	r17
     c90:	cf 93       	push	r28
     c92:	df 93       	push	r29
     c94:	18 2f       	mov	r17, r24
     c96:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     c98:	88 23       	and	r24, r24
     c9a:	01 f1       	breq	.+64     	; 0xcdc <xQueueGenericCreate+0x54>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     c9c:	8f e1       	ldi	r24, 0x1F	; 31
     c9e:	90 e0       	ldi	r25, 0x00	; 0
     ca0:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <pvPortMalloc>
     ca4:	e8 2e       	mov	r14, r24
     ca6:	e7 01       	movw	r28, r14
     ca8:	7e 01       	movw	r14, r28
     caa:	f9 2e       	mov	r15, r25
     cac:	e7 01       	movw	r28, r14
		if( pxNewQueue != NULL )
     cae:	20 97       	sbiw	r28, 0x00	; 0
     cb0:	a9 f0       	breq	.+42     	; 0xcdc <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     cb2:	01 9f       	mul	r16, r17
     cb4:	90 01       	movw	r18, r0
     cb6:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     cb8:	c9 01       	movw	r24, r18
     cba:	01 96       	adiw	r24, 0x01	; 1
     cbc:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <pvPortMalloc>
     cc0:	99 83       	std	Y+1, r25	; 0x01
     cc2:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     cc4:	00 97       	sbiw	r24, 0x00	; 0
     cc6:	39 f0       	breq	.+14     	; 0xcd6 <xQueueGenericCreate+0x4e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
     cc8:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     cca:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     ccc:	c7 01       	movw	r24, r14
     cce:	61 e0       	ldi	r22, 0x01	; 1
     cd0:	0e 94 f7 05 	call	0xbee	; 0xbee <xQueueGenericReset>
     cd4:	05 c0       	rjmp	.+10     	; 0xce0 <xQueueGenericCreate+0x58>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     cd6:	c7 01       	movw	r24, r14
     cd8:	0e 94 33 0c 	call	0x1866	; 0x1866 <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     cdc:	c0 e0       	ldi	r28, 0x00	; 0
     cde:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     ce0:	ce 01       	movw	r24, r28
     ce2:	df 91       	pop	r29
     ce4:	cf 91       	pop	r28
     ce6:	1f 91       	pop	r17
     ce8:	0f 91       	pop	r16
     cea:	ff 90       	pop	r15
     cec:	ef 90       	pop	r14
     cee:	08 95       	ret

00000cf0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     cf0:	6f 92       	push	r6
     cf2:	7f 92       	push	r7
     cf4:	9f 92       	push	r9
     cf6:	af 92       	push	r10
     cf8:	bf 92       	push	r11
     cfa:	cf 92       	push	r12
     cfc:	df 92       	push	r13
     cfe:	ef 92       	push	r14
     d00:	ff 92       	push	r15
     d02:	0f 93       	push	r16
     d04:	1f 93       	push	r17
     d06:	df 93       	push	r29
     d08:	cf 93       	push	r28
     d0a:	00 d0       	rcall	.+0      	; 0xd0c <xQueueGenericSend+0x1c>
     d0c:	00 d0       	rcall	.+0      	; 0xd0e <xQueueGenericSend+0x1e>
     d0e:	0f 92       	push	r0
     d10:	cd b7       	in	r28, 0x3d	; 61
     d12:	de b7       	in	r29, 0x3e	; 62
     d14:	3b 01       	movw	r6, r22
     d16:	5d 83       	std	Y+5, r21	; 0x05
     d18:	4c 83       	std	Y+4, r20	; 0x04
     d1a:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
     d1c:	8c 01       	movw	r16, r24
#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     d1e:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     d20:	7e 01       	movw	r14, r28
     d22:	08 94       	sec
     d24:	e1 1c       	adc	r14, r1
     d26:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     d28:	94 e0       	ldi	r25, 0x04	; 4
     d2a:	c9 2e       	mov	r12, r25
     d2c:	d1 2c       	mov	r13, r1
     d2e:	cc 0e       	add	r12, r28
     d30:	dd 1e       	adc	r13, r29
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     d32:	88 e0       	ldi	r24, 0x08	; 8
     d34:	a8 2e       	mov	r10, r24
     d36:	b1 2c       	mov	r11, r1
     d38:	a0 0e       	add	r10, r16
     d3a:	b1 1e       	adc	r11, r17
     d3c:	01 c0       	rjmp	.+2      	; 0xd40 <xQueueGenericSend+0x50>

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
     d3e:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     d40:	0f b6       	in	r0, 0x3f	; 63
     d42:	f8 94       	cli
     d44:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     d46:	f8 01       	movw	r30, r16
     d48:	92 8d       	ldd	r25, Z+26	; 0x1a
     d4a:	83 8d       	ldd	r24, Z+27	; 0x1b
     d4c:	98 17       	cp	r25, r24
     d4e:	18 f0       	brcs	.+6      	; 0xd56 <xQueueGenericSend+0x66>
     d50:	f9 2d       	mov	r31, r9
     d52:	f2 30       	cpi	r31, 0x02	; 2
     d54:	a9 f4       	brne	.+42     	; 0xd80 <xQueueGenericSend+0x90>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     d56:	c8 01       	movw	r24, r16
     d58:	b3 01       	movw	r22, r6
     d5a:	49 2d       	mov	r20, r9
     d5c:	0e 94 4d 05 	call	0xa9a	; 0xa9a <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d60:	f8 01       	movw	r30, r16
     d62:	81 89       	ldd	r24, Z+17	; 0x11
     d64:	88 23       	and	r24, r24
     d66:	41 f0       	breq	.+16     	; 0xd78 <xQueueGenericSend+0x88>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     d68:	c8 01       	movw	r24, r16
     d6a:	41 96       	adiw	r24, 0x11	; 17
     d6c:	0e 94 c5 04 	call	0x98a	; 0x98a <xTaskRemoveFromEventList>
     d70:	81 30       	cpi	r24, 0x01	; 1
     d72:	11 f4       	brne	.+4      	; 0xd78 <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     d74:	0e 94 ce 0c 	call	0x199c	; 0x199c <vPortYield>
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     d78:	0f 90       	pop	r0
     d7a:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     d7c:	81 e0       	ldi	r24, 0x01	; 1
     d7e:	4c c0       	rjmp	.+152    	; 0xe18 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     d80:	8c 81       	ldd	r24, Y+4	; 0x04
     d82:	9d 81       	ldd	r25, Y+5	; 0x05
     d84:	00 97       	sbiw	r24, 0x00	; 0
     d86:	19 f4       	brne	.+6      	; 0xd8e <xQueueGenericSend+0x9e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     d88:	0f 90       	pop	r0
     d8a:	0f be       	out	0x3f, r0	; 63
     d8c:	44 c0       	rjmp	.+136    	; 0xe16 <xQueueGenericSend+0x126>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
     d8e:	22 23       	and	r18, r18
     d90:	19 f4       	brne	.+6      	; 0xd98 <xQueueGenericSend+0xa8>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     d92:	c7 01       	movw	r24, r14
     d94:	0e 94 0a 05 	call	0xa14	; 0xa14 <vTaskSetTimeOutState>
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
     d98:	0f 90       	pop	r0
     d9a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     d9c:	0e 94 4a 02 	call	0x494	; 0x494 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     da0:	0f b6       	in	r0, 0x3f	; 63
     da2:	f8 94       	cli
     da4:	0f 92       	push	r0
     da6:	f8 01       	movw	r30, r16
     da8:	85 8d       	ldd	r24, Z+29	; 0x1d
     daa:	8f 3f       	cpi	r24, 0xFF	; 255
     dac:	09 f4       	brne	.+2      	; 0xdb0 <xQueueGenericSend+0xc0>
     dae:	15 8e       	std	Z+29, r1	; 0x1d
     db0:	f8 01       	movw	r30, r16
     db2:	86 8d       	ldd	r24, Z+30	; 0x1e
     db4:	8f 3f       	cpi	r24, 0xFF	; 255
     db6:	09 f4       	brne	.+2      	; 0xdba <xQueueGenericSend+0xca>
     db8:	16 8e       	std	Z+30, r1	; 0x1e
     dba:	0f 90       	pop	r0
     dbc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     dbe:	c7 01       	movw	r24, r14
     dc0:	b6 01       	movw	r22, r12
     dc2:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskCheckForTimeOut>
     dc6:	88 23       	and	r24, r24
     dc8:	09 f5       	brne	.+66     	; 0xe0c <xQueueGenericSend+0x11c>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	f8 94       	cli
     dce:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     dd0:	f8 01       	movw	r30, r16
     dd2:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     dd4:	0f 90       	pop	r0
     dd6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     dd8:	f8 01       	movw	r30, r16
     dda:	83 8d       	ldd	r24, Z+27	; 0x1b
     ddc:	98 17       	cp	r25, r24
     dde:	81 f4       	brne	.+32     	; 0xe00 <xQueueGenericSend+0x110>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     de0:	6c 81       	ldd	r22, Y+4	; 0x04
     de2:	7d 81       	ldd	r23, Y+5	; 0x05
     de4:	c5 01       	movw	r24, r10
     de6:	0e 94 a8 04 	call	0x950	; 0x950 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     dea:	c8 01       	movw	r24, r16
     dec:	0e 94 b7 05 	call	0xb6e	; 0xb6e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     df0:	0e 94 46 03 	call	0x68c	; 0x68c <xTaskResumeAll>
     df4:	88 23       	and	r24, r24
     df6:	09 f0       	breq	.+2      	; 0xdfa <xQueueGenericSend+0x10a>
     df8:	a2 cf       	rjmp	.-188    	; 0xd3e <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
     dfa:	0e 94 ce 0c 	call	0x199c	; 0x199c <vPortYield>
     dfe:	9f cf       	rjmp	.-194    	; 0xd3e <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     e00:	c8 01       	movw	r24, r16
     e02:	0e 94 b7 05 	call	0xb6e	; 0xb6e <prvUnlockQueue>
				( void ) xTaskResumeAll();
     e06:	0e 94 46 03 	call	0x68c	; 0x68c <xTaskResumeAll>
     e0a:	99 cf       	rjmp	.-206    	; 0xd3e <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     e0c:	c8 01       	movw	r24, r16
     e0e:	0e 94 b7 05 	call	0xb6e	; 0xb6e <prvUnlockQueue>
			( void ) xTaskResumeAll();
     e12:	0e 94 46 03 	call	0x68c	; 0x68c <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     e16:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     e18:	0f 90       	pop	r0
     e1a:	0f 90       	pop	r0
     e1c:	0f 90       	pop	r0
     e1e:	0f 90       	pop	r0
     e20:	0f 90       	pop	r0
     e22:	cf 91       	pop	r28
     e24:	df 91       	pop	r29
     e26:	1f 91       	pop	r17
     e28:	0f 91       	pop	r16
     e2a:	ff 90       	pop	r15
     e2c:	ef 90       	pop	r14
     e2e:	df 90       	pop	r13
     e30:	cf 90       	pop	r12
     e32:	bf 90       	pop	r11
     e34:	af 90       	pop	r10
     e36:	9f 90       	pop	r9
     e38:	7f 90       	pop	r7
     e3a:	6f 90       	pop	r6
     e3c:	08 95       	ret

00000e3e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     e3e:	ef 92       	push	r14
     e40:	ff 92       	push	r15
     e42:	0f 93       	push	r16
     e44:	1f 93       	push	r17
     e46:	cf 93       	push	r28
     e48:	df 93       	push	r29
     e4a:	8a 01       	movw	r16, r20
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
     e4c:	e8 2e       	mov	r14, r24
     e4e:	e7 01       	movw	r28, r14
     e50:	7e 01       	movw	r14, r28
     e52:	f9 2e       	mov	r15, r25
     e54:	e7 01       	movw	r28, r14
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     e56:	9a 8d       	ldd	r25, Y+26	; 0x1a
     e58:	8b 8d       	ldd	r24, Y+27	; 0x1b
     e5a:	98 17       	cp	r25, r24
     e5c:	10 f0       	brcs	.+4      	; 0xe62 <xQueueGenericSendFromISR+0x24>
     e5e:	22 30       	cpi	r18, 0x02	; 2
     e60:	d9 f4       	brne	.+54     	; 0xe98 <xQueueGenericSendFromISR+0x5a>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     e62:	ce 01       	movw	r24, r28
     e64:	42 2f       	mov	r20, r18
     e66:	0e 94 4d 05 	call	0xa9a	; 0xa9a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     e6a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e6c:	8f 3f       	cpi	r24, 0xFF	; 255
     e6e:	81 f4       	brne	.+32     	; 0xe90 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e70:	89 89       	ldd	r24, Y+17	; 0x11
     e72:	88 23       	and	r24, r24
     e74:	99 f0       	breq	.+38     	; 0xe9c <xQueueGenericSendFromISR+0x5e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e76:	ce 01       	movw	r24, r28
     e78:	41 96       	adiw	r24, 0x11	; 17
     e7a:	0e 94 c5 04 	call	0x98a	; 0x98a <xTaskRemoveFromEventList>
     e7e:	88 23       	and	r24, r24
     e80:	69 f0       	breq	.+26     	; 0xe9c <xQueueGenericSendFromISR+0x5e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     e82:	01 15       	cp	r16, r1
     e84:	11 05       	cpc	r17, r1
     e86:	51 f0       	breq	.+20     	; 0xe9c <xQueueGenericSendFromISR+0x5e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     e88:	81 e0       	ldi	r24, 0x01	; 1
     e8a:	f8 01       	movw	r30, r16
     e8c:	80 83       	st	Z, r24
     e8e:	07 c0       	rjmp	.+14     	; 0xe9e <xQueueGenericSendFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     e90:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e92:	8f 5f       	subi	r24, 0xFF	; 255
     e94:	8e 8f       	std	Y+30, r24	; 0x1e
     e96:	02 c0       	rjmp	.+4      	; 0xe9c <xQueueGenericSendFromISR+0x5e>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     e98:	80 e0       	ldi	r24, 0x00	; 0
     e9a:	01 c0       	rjmp	.+2      	; 0xe9e <xQueueGenericSendFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     e9c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     e9e:	df 91       	pop	r29
     ea0:	cf 91       	pop	r28
     ea2:	1f 91       	pop	r17
     ea4:	0f 91       	pop	r16
     ea6:	ff 90       	pop	r15
     ea8:	ef 90       	pop	r14
     eaa:	08 95       	ret

00000eac <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     eac:	6f 92       	push	r6
     eae:	7f 92       	push	r7
     eb0:	9f 92       	push	r9
     eb2:	af 92       	push	r10
     eb4:	bf 92       	push	r11
     eb6:	cf 92       	push	r12
     eb8:	df 92       	push	r13
     eba:	ef 92       	push	r14
     ebc:	ff 92       	push	r15
     ebe:	0f 93       	push	r16
     ec0:	1f 93       	push	r17
     ec2:	df 93       	push	r29
     ec4:	cf 93       	push	r28
     ec6:	00 d0       	rcall	.+0      	; 0xec8 <xQueueGenericReceive+0x1c>
     ec8:	00 d0       	rcall	.+0      	; 0xeca <xQueueGenericReceive+0x1e>
     eca:	0f 92       	push	r0
     ecc:	cd b7       	in	r28, 0x3d	; 61
     ece:	de b7       	in	r29, 0x3e	; 62
     ed0:	3b 01       	movw	r6, r22
     ed2:	5d 83       	std	Y+5, r21	; 0x05
     ed4:	4c 83       	std	Y+4, r20	; 0x04
     ed6:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
     ed8:	8c 01       	movw	r16, r24
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     eda:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     edc:	7e 01       	movw	r14, r28
     ede:	08 94       	sec
     ee0:	e1 1c       	adc	r14, r1
     ee2:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ee4:	44 e0       	ldi	r20, 0x04	; 4
     ee6:	c4 2e       	mov	r12, r20
     ee8:	d1 2c       	mov	r13, r1
     eea:	cc 0e       	add	r12, r28
     eec:	dd 1e       	adc	r13, r29
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     eee:	31 e1       	ldi	r19, 0x11	; 17
     ef0:	a3 2e       	mov	r10, r19
     ef2:	b1 2c       	mov	r11, r1
     ef4:	a8 0e       	add	r10, r24
     ef6:	b9 1e       	adc	r11, r25
     ef8:	01 c0       	rjmp	.+2      	; 0xefc <xQueueGenericReceive+0x50>
signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
     efa:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     efc:	0f b6       	in	r0, 0x3f	; 63
     efe:	f8 94       	cli
     f00:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     f02:	f8 01       	movw	r30, r16
     f04:	82 8d       	ldd	r24, Z+26	; 0x1a
     f06:	88 23       	and	r24, r24
     f08:	41 f1       	breq	.+80     	; 0xf5a <xQueueGenericReceive+0xae>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     f0a:	e6 80       	ldd	r14, Z+6	; 0x06
     f0c:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     f0e:	c8 01       	movw	r24, r16
     f10:	b3 01       	movw	r22, r6
     f12:	0e 94 97 05 	call	0xb2e	; 0xb2e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     f16:	99 20       	and	r9, r9
     f18:	71 f4       	brne	.+28     	; 0xf36 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     f1a:	f8 01       	movw	r30, r16
     f1c:	82 8d       	ldd	r24, Z+26	; 0x1a
     f1e:	81 50       	subi	r24, 0x01	; 1
     f20:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f22:	80 85       	ldd	r24, Z+8	; 0x08
     f24:	88 23       	and	r24, r24
     f26:	a9 f0       	breq	.+42     	; 0xf52 <xQueueGenericReceive+0xa6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     f28:	c8 01       	movw	r24, r16
     f2a:	08 96       	adiw	r24, 0x08	; 8
     f2c:	0e 94 c5 04 	call	0x98a	; 0x98a <xTaskRemoveFromEventList>
     f30:	81 30       	cpi	r24, 0x01	; 1
     f32:	79 f4       	brne	.+30     	; 0xf52 <xQueueGenericReceive+0xa6>
     f34:	0c c0       	rjmp	.+24     	; 0xf4e <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     f36:	f8 01       	movw	r30, r16
     f38:	f7 82       	std	Z+7, r15	; 0x07
     f3a:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f3c:	81 89       	ldd	r24, Z+17	; 0x11
     f3e:	88 23       	and	r24, r24
     f40:	41 f0       	breq	.+16     	; 0xf52 <xQueueGenericReceive+0xa6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f42:	c8 01       	movw	r24, r16
     f44:	41 96       	adiw	r24, 0x11	; 17
     f46:	0e 94 c5 04 	call	0x98a	; 0x98a <xTaskRemoveFromEventList>
     f4a:	88 23       	and	r24, r24
     f4c:	11 f0       	breq	.+4      	; 0xf52 <xQueueGenericReceive+0xa6>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     f4e:	0e 94 ce 0c 	call	0x199c	; 0x199c <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
     f52:	0f 90       	pop	r0
     f54:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     f56:	81 e0       	ldi	r24, 0x01	; 1
     f58:	4a c0       	rjmp	.+148    	; 0xfee <xQueueGenericReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     f5a:	8c 81       	ldd	r24, Y+4	; 0x04
     f5c:	9d 81       	ldd	r25, Y+5	; 0x05
     f5e:	00 97       	sbiw	r24, 0x00	; 0
     f60:	19 f4       	brne	.+6      	; 0xf68 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f62:	0f 90       	pop	r0
     f64:	0f be       	out	0x3f, r0	; 63
     f66:	42 c0       	rjmp	.+132    	; 0xfec <xQueueGenericReceive+0x140>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
     f68:	22 23       	and	r18, r18
     f6a:	19 f4       	brne	.+6      	; 0xf72 <xQueueGenericReceive+0xc6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f6c:	c7 01       	movw	r24, r14
     f6e:	0e 94 0a 05 	call	0xa14	; 0xa14 <vTaskSetTimeOutState>
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
     f72:	0f 90       	pop	r0
     f74:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f76:	0e 94 4a 02 	call	0x494	; 0x494 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f7a:	0f b6       	in	r0, 0x3f	; 63
     f7c:	f8 94       	cli
     f7e:	0f 92       	push	r0
     f80:	f8 01       	movw	r30, r16
     f82:	85 8d       	ldd	r24, Z+29	; 0x1d
     f84:	8f 3f       	cpi	r24, 0xFF	; 255
     f86:	09 f4       	brne	.+2      	; 0xf8a <xQueueGenericReceive+0xde>
     f88:	15 8e       	std	Z+29, r1	; 0x1d
     f8a:	f8 01       	movw	r30, r16
     f8c:	86 8d       	ldd	r24, Z+30	; 0x1e
     f8e:	8f 3f       	cpi	r24, 0xFF	; 255
     f90:	09 f4       	brne	.+2      	; 0xf94 <xQueueGenericReceive+0xe8>
     f92:	16 8e       	std	Z+30, r1	; 0x1e
     f94:	0f 90       	pop	r0
     f96:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f98:	c7 01       	movw	r24, r14
     f9a:	b6 01       	movw	r22, r12
     f9c:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskCheckForTimeOut>
     fa0:	88 23       	and	r24, r24
     fa2:	f9 f4       	brne	.+62     	; 0xfe2 <xQueueGenericReceive+0x136>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     fa4:	0f b6       	in	r0, 0x3f	; 63
     fa6:	f8 94       	cli
     fa8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
     faa:	f8 01       	movw	r30, r16
     fac:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     fae:	0f 90       	pop	r0
     fb0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     fb2:	88 23       	and	r24, r24
     fb4:	81 f4       	brne	.+32     	; 0xfd6 <xQueueGenericReceive+0x12a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     fb6:	6c 81       	ldd	r22, Y+4	; 0x04
     fb8:	7d 81       	ldd	r23, Y+5	; 0x05
     fba:	c5 01       	movw	r24, r10
     fbc:	0e 94 a8 04 	call	0x950	; 0x950 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     fc0:	c8 01       	movw	r24, r16
     fc2:	0e 94 b7 05 	call	0xb6e	; 0xb6e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     fc6:	0e 94 46 03 	call	0x68c	; 0x68c <xTaskResumeAll>
     fca:	88 23       	and	r24, r24
     fcc:	09 f0       	breq	.+2      	; 0xfd0 <xQueueGenericReceive+0x124>
     fce:	95 cf       	rjmp	.-214    	; 0xefa <xQueueGenericReceive+0x4e>
				{
					portYIELD_WITHIN_API();
     fd0:	0e 94 ce 0c 	call	0x199c	; 0x199c <vPortYield>
     fd4:	92 cf       	rjmp	.-220    	; 0xefa <xQueueGenericReceive+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     fd6:	c8 01       	movw	r24, r16
     fd8:	0e 94 b7 05 	call	0xb6e	; 0xb6e <prvUnlockQueue>
				( void ) xTaskResumeAll();
     fdc:	0e 94 46 03 	call	0x68c	; 0x68c <xTaskResumeAll>
     fe0:	8c cf       	rjmp	.-232    	; 0xefa <xQueueGenericReceive+0x4e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     fe2:	c8 01       	movw	r24, r16
     fe4:	0e 94 b7 05 	call	0xb6e	; 0xb6e <prvUnlockQueue>
			( void ) xTaskResumeAll();
     fe8:	0e 94 46 03 	call	0x68c	; 0x68c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     fec:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     fee:	0f 90       	pop	r0
     ff0:	0f 90       	pop	r0
     ff2:	0f 90       	pop	r0
     ff4:	0f 90       	pop	r0
     ff6:	0f 90       	pop	r0
     ff8:	cf 91       	pop	r28
     ffa:	df 91       	pop	r29
     ffc:	1f 91       	pop	r17
     ffe:	0f 91       	pop	r16
    1000:	ff 90       	pop	r15
    1002:	ef 90       	pop	r14
    1004:	df 90       	pop	r13
    1006:	cf 90       	pop	r12
    1008:	bf 90       	pop	r11
    100a:	af 90       	pop	r10
    100c:	9f 90       	pop	r9
    100e:	7f 90       	pop	r7
    1010:	6f 90       	pop	r6
    1012:	08 95       	ret

00001014 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1014:	ef 92       	push	r14
    1016:	ff 92       	push	r15
    1018:	0f 93       	push	r16
    101a:	1f 93       	push	r17
    101c:	cf 93       	push	r28
    101e:	df 93       	push	r29
    1020:	8a 01       	movw	r16, r20
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
    1022:	e8 2e       	mov	r14, r24
    1024:	e7 01       	movw	r28, r14
    1026:	7e 01       	movw	r14, r28
    1028:	f9 2e       	mov	r15, r25
    102a:	e7 01       	movw	r28, r14
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    102c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    102e:	88 23       	and	r24, r24
    1030:	e9 f0       	breq	.+58     	; 0x106c <xQueueReceiveFromISR+0x58>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1032:	c7 01       	movw	r24, r14
    1034:	0e 94 97 05 	call	0xb2e	; 0xb2e <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1038:	8a 8d       	ldd	r24, Y+26	; 0x1a
    103a:	81 50       	subi	r24, 0x01	; 1
    103c:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    103e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1040:	8f 3f       	cpi	r24, 0xFF	; 255
    1042:	81 f4       	brne	.+32     	; 0x1064 <xQueueReceiveFromISR+0x50>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1044:	88 85       	ldd	r24, Y+8	; 0x08
    1046:	88 23       	and	r24, r24
    1048:	99 f0       	breq	.+38     	; 0x1070 <xQueueReceiveFromISR+0x5c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    104a:	c7 01       	movw	r24, r14
    104c:	08 96       	adiw	r24, 0x08	; 8
    104e:	0e 94 c5 04 	call	0x98a	; 0x98a <xTaskRemoveFromEventList>
    1052:	88 23       	and	r24, r24
    1054:	69 f0       	breq	.+26     	; 0x1070 <xQueueReceiveFromISR+0x5c>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1056:	01 15       	cp	r16, r1
    1058:	11 05       	cpc	r17, r1
    105a:	51 f0       	breq	.+20     	; 0x1070 <xQueueReceiveFromISR+0x5c>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    105c:	81 e0       	ldi	r24, 0x01	; 1
    105e:	f8 01       	movw	r30, r16
    1060:	80 83       	st	Z, r24
    1062:	07 c0       	rjmp	.+14     	; 0x1072 <xQueueReceiveFromISR+0x5e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1064:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1066:	8f 5f       	subi	r24, 0xFF	; 255
    1068:	8d 8f       	std	Y+29, r24	; 0x1d
    106a:	02 c0       	rjmp	.+4      	; 0x1070 <xQueueReceiveFromISR+0x5c>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    106c:	80 e0       	ldi	r24, 0x00	; 0
    106e:	01 c0       	rjmp	.+2      	; 0x1072 <xQueueReceiveFromISR+0x5e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1070:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	1f 91       	pop	r17
    1078:	0f 91       	pop	r16
    107a:	ff 90       	pop	r15
    107c:	ef 90       	pop	r14
    107e:	08 95       	ret

00001080 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueuePeekFromISR( xQueueHandle xQueue,  void * const pvBuffer )
{
    1080:	ef 92       	push	r14
    1082:	ff 92       	push	r15
    1084:	0f 93       	push	r16
    1086:	1f 93       	push	r17
    1088:	cf 93       	push	r28
    108a:	df 93       	push	r29
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
    108c:	e8 2e       	mov	r14, r24
    108e:	e7 01       	movw	r28, r14
    1090:	7e 01       	movw	r14, r28
    1092:	f9 2e       	mov	r15, r25
    1094:	e7 01       	movw	r28, r14
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1096:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1098:	88 23       	and	r24, r24
    109a:	49 f0       	breq	.+18     	; 0x10ae <xQueuePeekFromISR+0x2e>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    109c:	0e 81       	ldd	r16, Y+6	; 0x06
    109e:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    10a0:	c7 01       	movw	r24, r14
    10a2:	0e 94 97 05 	call	0xb2e	; 0xb2e <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    10a6:	1f 83       	std	Y+7, r17	; 0x07
    10a8:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    10aa:	81 e0       	ldi	r24, 0x01	; 1
    10ac:	01 c0       	rjmp	.+2      	; 0x10b0 <xQueuePeekFromISR+0x30>
		}
		else
		{
			xReturn = pdFAIL;
    10ae:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    10b0:	df 91       	pop	r29
    10b2:	cf 91       	pop	r28
    10b4:	1f 91       	pop	r17
    10b6:	0f 91       	pop	r16
    10b8:	ff 90       	pop	r15
    10ba:	ef 90       	pop	r14
    10bc:	08 95       	ret

000010be <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    10be:	0f b6       	in	r0, 0x3f	; 63
    10c0:	f8 94       	cli
    10c2:	0f 92       	push	r0
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    10c4:	fc 01       	movw	r30, r24
    10c6:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    10c8:	0f 90       	pop	r0
    10ca:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    10cc:	08 95       	ret

000010ce <uxQueueSpacesAvailable>:
unsigned portBASE_TYPE uxQueueSpacesAvailable( const xQueueHandle xQueue )
{
unsigned portBASE_TYPE uxReturn;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    10ce:	fc 01       	movw	r30, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    10d0:	0f b6       	in	r0, 0x3f	; 63
    10d2:	f8 94       	cli
    10d4:	0f 92       	push	r0
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    10d6:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    10d8:	0f 90       	pop	r0
    10da:	0f be       	out	0x3f, r0	; 63

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    10dc:	83 8d       	ldd	r24, Z+27	; 0x1b
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    10de:	89 1b       	sub	r24, r25
    10e0:	08 95       	ret

000010e2 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    10e2:	fc 01       	movw	r30, r24
    10e4:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    10e6:	08 95       	ret

000010e8 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle xQueue )
{
    10e8:	ef 92       	push	r14
    10ea:	ff 92       	push	r15
    10ec:	cf 93       	push	r28
    10ee:	df 93       	push	r29
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
    10f0:	e8 2e       	mov	r14, r24
    10f2:	e7 01       	movw	r28, r14
    10f4:	7e 01       	movw	r14, r28
    10f6:	f9 2e       	mov	r15, r25
    10f8:	e7 01       	movw	r28, r14
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
    10fa:	88 81       	ld	r24, Y
    10fc:	99 81       	ldd	r25, Y+1	; 0x01
    10fe:	0e 94 33 0c 	call	0x1866	; 0x1866 <vPortFree>
	vPortFree( pxQueue );
    1102:	c7 01       	movw	r24, r14
    1104:	0e 94 33 0c 	call	0x1866	; 0x1866 <vPortFree>
}
    1108:	df 91       	pop	r29
    110a:	cf 91       	pop	r28
    110c:	ff 90       	pop	r15
    110e:	ef 90       	pop	r14
    1110:	08 95       	ret

00001112 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
    1112:	fc 01       	movw	r30, r24
    1114:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    1116:	81 e0       	ldi	r24, 0x01	; 1
    1118:	91 11       	cpse	r25, r1
    111a:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    111c:	08 95       	ret

0000111e <xQueueIsQueueFullFromISR>:
signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
    111e:	fc 01       	movw	r30, r24
    1120:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    1122:	81 e0       	ldi	r24, 0x01	; 1
    1124:	93 8d       	ldd	r25, Z+27	; 0x1b
    1126:	29 13       	cpse	r18, r25
    1128:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    112a:	08 95       	ret

0000112c <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait )
	{
    112c:	ef 92       	push	r14
    112e:	ff 92       	push	r15
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
	signed portBASE_TYPE xReturn;
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
    1134:	e8 2e       	mov	r14, r24
    1136:	e7 01       	movw	r28, r14
    1138:	7e 01       	movw	r14, r28
    113a:	f9 2e       	mov	r15, r25
    113c:	e7 01       	movw	r28, r14

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    113e:	f8 94       	cli

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1140:	0f b6       	in	r0, 0x3f	; 63
    1142:	f8 94       	cli
    1144:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1146:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1148:	8b 8d       	ldd	r24, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    114a:	0f 90       	pop	r0
    114c:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    114e:	98 17       	cp	r25, r24
    1150:	79 f4       	brne	.+30     	; 0x1170 <xQueueCRSend+0x44>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( portTickType ) 0 )
    1152:	41 15       	cp	r20, r1
    1154:	51 05       	cpc	r21, r1
    1156:	49 f0       	breq	.+18     	; 0x116a <xQueueCRSend+0x3e>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1158:	b7 01       	movw	r22, r14
    115a:	68 5f       	subi	r22, 0xF8	; 248
    115c:	7f 4f       	sbci	r23, 0xFF	; 255
    115e:	ca 01       	movw	r24, r20
    1160:	0e 94 a8 0a 	call	0x1550	; 0x1550 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1164:	78 94       	sei
					return errQUEUE_BLOCKED;
    1166:	8c ef       	ldi	r24, 0xFC	; 252
    1168:	1c c0       	rjmp	.+56     	; 0x11a2 <xQueueCRSend+0x76>
				}
				else
				{
					portENABLE_INTERRUPTS();
    116a:	78 94       	sei
					return errQUEUE_FULL;
    116c:	80 e0       	ldi	r24, 0x00	; 0
    116e:	19 c0       	rjmp	.+50     	; 0x11a2 <xQueueCRSend+0x76>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1170:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1172:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1174:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1176:	98 17       	cp	r25, r24
    1178:	70 f4       	brcc	.+28     	; 0x1196 <xQueueCRSend+0x6a>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    117a:	c7 01       	movw	r24, r14
    117c:	40 e0       	ldi	r20, 0x00	; 0
    117e:	0e 94 4d 05 	call	0xa9a	; 0xa9a <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1182:	89 89       	ldd	r24, Y+17	; 0x11
    1184:	88 23       	and	r24, r24
    1186:	49 f0       	breq	.+18     	; 0x119a <xQueueCRSend+0x6e>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1188:	c7 01       	movw	r24, r14
    118a:	41 96       	adiw	r24, 0x11	; 17
    118c:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xCoRoutineRemoveFromEventList>
    1190:	88 23       	and	r24, r24
    1192:	29 f4       	brne	.+10     	; 0x119e <xQueueCRSend+0x72>
    1194:	02 c0       	rjmp	.+4      	; 0x119a <xQueueCRSend+0x6e>
					}
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1196:	80 e0       	ldi	r24, 0x00	; 0
    1198:	03 c0       	rjmp	.+6      	; 0x11a0 <xQueueCRSend+0x74>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    119a:	81 e0       	ldi	r24, 0x01	; 1
    119c:	01 c0       	rjmp	.+2      	; 0x11a0 <xQueueCRSend+0x74>
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    119e:	8b ef       	ldi	r24, 0xFB	; 251
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    11a0:	78 94       	sei

		return xReturn;
	}
    11a2:	df 91       	pop	r29
    11a4:	cf 91       	pop	r28
    11a6:	ff 90       	pop	r15
    11a8:	ef 90       	pop	r14
    11aa:	08 95       	ret

000011ac <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait )
	{
    11ac:	ef 92       	push	r14
    11ae:	ff 92       	push	r15
    11b0:	cf 93       	push	r28
    11b2:	df 93       	push	r29
	signed portBASE_TYPE xReturn;
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
    11b4:	e8 2e       	mov	r14, r24
    11b6:	e7 01       	movw	r28, r14
    11b8:	7e 01       	movw	r14, r28
    11ba:	f9 2e       	mov	r15, r25
    11bc:	e7 01       	movw	r28, r14

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    11be:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
    11c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11c2:	88 23       	and	r24, r24
    11c4:	79 f4       	brne	.+30     	; 0x11e4 <xQueueCRReceive+0x38>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( portTickType ) 0 )
    11c6:	41 15       	cp	r20, r1
    11c8:	51 05       	cpc	r21, r1
    11ca:	49 f0       	breq	.+18     	; 0x11de <xQueueCRReceive+0x32>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    11cc:	b7 01       	movw	r22, r14
    11ce:	6f 5e       	subi	r22, 0xEF	; 239
    11d0:	7f 4f       	sbci	r23, 0xFF	; 255
    11d2:	ca 01       	movw	r24, r20
    11d4:	0e 94 a8 0a 	call	0x1550	; 0x1550 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    11d8:	78 94       	sei
					return errQUEUE_BLOCKED;
    11da:	8c ef       	ldi	r24, 0xFC	; 252
    11dc:	33 c0       	rjmp	.+102    	; 0x1244 <xQueueCRReceive+0x98>
				}
				else
				{
					portENABLE_INTERRUPTS();
    11de:	78 94       	sei
					return errQUEUE_FULL;
    11e0:	80 e0       	ldi	r24, 0x00	; 0
    11e2:	30 c0       	rjmp	.+96     	; 0x1244 <xQueueCRReceive+0x98>
				}
			}
		}
		portENABLE_INTERRUPTS();
    11e4:	78 94       	sei

		portDISABLE_INTERRUPTS();
    11e6:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    11e8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11ea:	88 23       	and	r24, r24
    11ec:	29 f1       	breq	.+74     	; 0x1238 <xQueueCRReceive+0x8c>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    11ee:	4c 8d       	ldd	r20, Y+28	; 0x1c
    11f0:	2e 81       	ldd	r18, Y+6	; 0x06
    11f2:	3f 81       	ldd	r19, Y+7	; 0x07
    11f4:	24 0f       	add	r18, r20
    11f6:	31 1d       	adc	r19, r1
    11f8:	3f 83       	std	Y+7, r19	; 0x07
    11fa:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    11fc:	ea 81       	ldd	r30, Y+2	; 0x02
    11fe:	fb 81       	ldd	r31, Y+3	; 0x03
    1200:	2e 17       	cp	r18, r30
    1202:	3f 07       	cpc	r19, r31
    1204:	20 f0       	brcs	.+8      	; 0x120e <xQueueCRReceive+0x62>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1206:	28 81       	ld	r18, Y
    1208:	39 81       	ldd	r19, Y+1	; 0x01
    120a:	3f 83       	std	Y+7, r19	; 0x07
    120c:	2e 83       	std	Y+6, r18	; 0x06
				}
				--( pxQueue->uxMessagesWaiting );
    120e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1210:	81 50       	subi	r24, 0x01	; 1
    1212:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1214:	3e 81       	ldd	r19, Y+6	; 0x06
    1216:	2f 81       	ldd	r18, Y+7	; 0x07
    1218:	cb 01       	movw	r24, r22
    121a:	63 2f       	mov	r22, r19
    121c:	72 2f       	mov	r23, r18
    121e:	50 e0       	ldi	r21, 0x00	; 0
    1220:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1224:	88 85       	ldd	r24, Y+8	; 0x08
    1226:	88 23       	and	r24, r24
    1228:	49 f0       	breq	.+18     	; 0x123c <xQueueCRReceive+0x90>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    122a:	ce 01       	movw	r24, r28
    122c:	08 96       	adiw	r24, 0x08	; 8
    122e:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xCoRoutineRemoveFromEventList>
    1232:	88 23       	and	r24, r24
    1234:	29 f4       	brne	.+10     	; 0x1240 <xQueueCRReceive+0x94>
    1236:	02 c0       	rjmp	.+4      	; 0x123c <xQueueCRReceive+0x90>
					}
				}
			}
			else
			{
				xReturn = pdFAIL;
    1238:	80 e0       	ldi	r24, 0x00	; 0
    123a:	03 c0       	rjmp	.+6      	; 0x1242 <xQueueCRReceive+0x96>
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    123c:	81 e0       	ldi	r24, 0x01	; 1
    123e:	01 c0       	rjmp	.+2      	; 0x1242 <xQueueCRReceive+0x96>
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
					{
						xReturn = errQUEUE_YIELD;
    1240:	8b ef       	ldi	r24, 0xFB	; 251
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    1242:	78 94       	sei

		return xReturn;
	}
    1244:	df 91       	pop	r29
    1246:	cf 91       	pop	r28
    1248:	ff 90       	pop	r15
    124a:	ef 90       	pop	r14
    124c:	08 95       	ret

0000124e <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
	{
    124e:	ef 92       	push	r14
    1250:	ff 92       	push	r15
    1252:	1f 93       	push	r17
    1254:	cf 93       	push	r28
    1256:	df 93       	push	r29
    1258:	14 2f       	mov	r17, r20
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
    125a:	e8 2e       	mov	r14, r24
    125c:	e7 01       	movw	r28, r14
    125e:	7e 01       	movw	r14, r28
    1260:	f9 2e       	mov	r15, r25
    1262:	e7 01       	movw	r28, r14

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1264:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1266:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1268:	98 17       	cp	r25, r24
    126a:	88 f4       	brcc	.+34     	; 0x128e <xQueueCRSendFromISR+0x40>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    126c:	c7 01       	movw	r24, r14
    126e:	40 e0       	ldi	r20, 0x00	; 0
    1270:	0e 94 4d 05 	call	0xa9a	; 0xa9a <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1274:	11 23       	and	r17, r17
    1276:	59 f4       	brne	.+22     	; 0x128e <xQueueCRSendFromISR+0x40>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1278:	89 89       	ldd	r24, Y+17	; 0x11
    127a:	88 23       	and	r24, r24
    127c:	41 f0       	breq	.+16     	; 0x128e <xQueueCRSendFromISR+0x40>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    127e:	c7 01       	movw	r24, r14
    1280:	41 96       	adiw	r24, 0x11	; 17
    1282:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xCoRoutineRemoveFromEventList>
#endif /* configUSE_CO_ROUTINES */
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
    1286:	11 e0       	ldi	r17, 0x01	; 1
    1288:	88 23       	and	r24, r24
    128a:	09 f4       	brne	.+2      	; 0x128e <xQueueCRSendFromISR+0x40>
    128c:	10 e0       	ldi	r17, 0x00	; 0
				}
			}
		}

		return xCoRoutinePreviouslyWoken;
	}
    128e:	81 2f       	mov	r24, r17
    1290:	df 91       	pop	r29
    1292:	cf 91       	pop	r28
    1294:	1f 91       	pop	r17
    1296:	ff 90       	pop	r15
    1298:	ef 90       	pop	r14
    129a:	08 95       	ret

0000129c <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
	{
    129c:	ef 92       	push	r14
    129e:	ff 92       	push	r15
    12a0:	0f 93       	push	r16
    12a2:	1f 93       	push	r17
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	8a 01       	movw	r16, r20
	signed portBASE_TYPE xReturn;
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
    12aa:	e8 2e       	mov	r14, r24
    12ac:	e7 01       	movw	r28, r14
    12ae:	7e 01       	movw	r14, r28
    12b0:	f9 2e       	mov	r15, r25
    12b2:	e7 01       	movw	r28, r14

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    12b4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    12b6:	88 23       	and	r24, r24
    12b8:	61 f1       	breq	.+88     	; 0x1312 <xQueueCRReceiveFromISR+0x76>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    12ba:	4c 8d       	ldd	r20, Y+28	; 0x1c
    12bc:	2e 81       	ldd	r18, Y+6	; 0x06
    12be:	3f 81       	ldd	r19, Y+7	; 0x07
    12c0:	24 0f       	add	r18, r20
    12c2:	31 1d       	adc	r19, r1
    12c4:	3f 83       	std	Y+7, r19	; 0x07
    12c6:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    12c8:	ea 81       	ldd	r30, Y+2	; 0x02
    12ca:	fb 81       	ldd	r31, Y+3	; 0x03
    12cc:	2e 17       	cp	r18, r30
    12ce:	3f 07       	cpc	r19, r31
    12d0:	20 f0       	brcs	.+8      	; 0x12da <xQueueCRReceiveFromISR+0x3e>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    12d2:	28 81       	ld	r18, Y
    12d4:	39 81       	ldd	r19, Y+1	; 0x01
    12d6:	3f 83       	std	Y+7, r19	; 0x07
    12d8:	2e 83       	std	Y+6, r18	; 0x06
			}
			--( pxQueue->uxMessagesWaiting );
    12da:	8a 8d       	ldd	r24, Y+26	; 0x1a
    12dc:	81 50       	subi	r24, 0x01	; 1
    12de:	8a 8f       	std	Y+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    12e0:	3e 81       	ldd	r19, Y+6	; 0x06
    12e2:	2f 81       	ldd	r18, Y+7	; 0x07
    12e4:	cb 01       	movw	r24, r22
    12e6:	63 2f       	mov	r22, r19
    12e8:	72 2f       	mov	r23, r18
    12ea:	50 e0       	ldi	r21, 0x00	; 0
    12ec:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    12f0:	f8 01       	movw	r30, r16
    12f2:	80 81       	ld	r24, Z
    12f4:	88 23       	and	r24, r24
    12f6:	79 f4       	brne	.+30     	; 0x1316 <xQueueCRReceiveFromISR+0x7a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12f8:	88 85       	ldd	r24, Y+8	; 0x08
    12fa:	88 23       	and	r24, r24
    12fc:	61 f0       	breq	.+24     	; 0x1316 <xQueueCRReceiveFromISR+0x7a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12fe:	ce 01       	movw	r24, r28
    1300:	08 96       	adiw	r24, 0x08	; 8
    1302:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xCoRoutineRemoveFromEventList>
    1306:	88 23       	and	r24, r24
    1308:	31 f0       	breq	.+12     	; 0x1316 <xQueueCRReceiveFromISR+0x7a>
					{
						*pxCoRoutineWoken = pdTRUE;
    130a:	81 e0       	ldi	r24, 0x01	; 1
    130c:	f8 01       	movw	r30, r16
    130e:	80 83       	st	Z, r24
    1310:	03 c0       	rjmp	.+6      	; 0x1318 <xQueueCRReceiveFromISR+0x7c>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1312:	80 e0       	ldi	r24, 0x00	; 0
    1314:	01 c0       	rjmp	.+2      	; 0x1318 <xQueueCRReceiveFromISR+0x7c>
						*pxCoRoutineWoken = pdTRUE;
					}
				}
			}

			xReturn = pdPASS;
    1316:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    1318:	df 91       	pop	r29
    131a:	cf 91       	pop	r28
    131c:	1f 91       	pop	r17
    131e:	0f 91       	pop	r16
    1320:	ff 90       	pop	r15
    1322:	ef 90       	pop	r14
    1324:	08 95       	ret

00001326 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList * const pxList )
{
    1326:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1328:	03 96       	adiw	r24, 0x03	; 3
    132a:	92 83       	std	Z+2, r25	; 0x02
    132c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    132e:	2f ef       	ldi	r18, 0xFF	; 255
    1330:	3f ef       	ldi	r19, 0xFF	; 255
    1332:	34 83       	std	Z+4, r19	; 0x04
    1334:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1336:	96 83       	std	Z+6, r25	; 0x06
    1338:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    133a:	90 87       	std	Z+8, r25	; 0x08
    133c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    133e:	10 82       	st	Z, r1
}
    1340:	08 95       	ret

00001342 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1342:	fc 01       	movw	r30, r24
    1344:	11 86       	std	Z+9, r1	; 0x09
    1346:	10 86       	std	Z+8, r1	; 0x08
}
    1348:	08 95       	ret

0000134a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList * const pxList, xListItem * const pxNewListItem )
{
    134a:	cf 93       	push	r28
    134c:	df 93       	push	r29
    134e:	9c 01       	movw	r18, r24
    1350:	db 01       	movw	r26, r22
xListItem * pxIndex;

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry. */
	pxIndex = pxList->pxIndex;
    1352:	fc 01       	movw	r30, r24
    1354:	c1 81       	ldd	r28, Z+1	; 0x01
    1356:	d2 81       	ldd	r29, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex;
    1358:	13 96       	adiw	r26, 0x03	; 3
    135a:	dc 93       	st	X, r29
    135c:	ce 93       	st	-X, r28
    135e:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1360:	8c 81       	ldd	r24, Y+4	; 0x04
    1362:	9d 81       	ldd	r25, Y+5	; 0x05
    1364:	15 96       	adiw	r26, 0x05	; 5
    1366:	9c 93       	st	X, r25
    1368:	8e 93       	st	-X, r24
    136a:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    136c:	8c 81       	ldd	r24, Y+4	; 0x04
    136e:	9d 81       	ldd	r25, Y+5	; 0x05
    1370:	fc 01       	movw	r30, r24
    1372:	73 83       	std	Z+3, r23	; 0x03
    1374:	62 83       	std	Z+2, r22	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1376:	7d 83       	std	Y+5, r23	; 0x05
    1378:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    137a:	19 96       	adiw	r26, 0x09	; 9
    137c:	3c 93       	st	X, r19
    137e:	2e 93       	st	-X, r18
    1380:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1382:	f9 01       	movw	r30, r18
    1384:	80 81       	ld	r24, Z
    1386:	8f 5f       	subi	r24, 0xFF	; 255
    1388:	80 83       	st	Z, r24
}
    138a:	df 91       	pop	r29
    138c:	cf 91       	pop	r28
    138e:	08 95       	ret

00001390 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList * const pxList, xListItem * const pxNewListItem )
{
    1390:	0f 93       	push	r16
    1392:	1f 93       	push	r17
    1394:	cf 93       	push	r28
    1396:	df 93       	push	r29
    1398:	8c 01       	movw	r16, r24
    139a:	db 01       	movw	r26, r22
xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    139c:	8d 91       	ld	r24, X+
    139e:	9c 91       	ld	r25, X
    13a0:	11 97       	sbiw	r26, 0x01	; 1
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    13a2:	2f ef       	ldi	r18, 0xFF	; 255
    13a4:	8f 3f       	cpi	r24, 0xFF	; 255
    13a6:	92 07       	cpc	r25, r18
    13a8:	21 f4       	brne	.+8      	; 0x13b2 <vListInsert+0x22>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    13aa:	f8 01       	movw	r30, r16
    13ac:	c7 81       	ldd	r28, Z+7	; 0x07
    13ae:	d0 85       	ldd	r29, Z+8	; 0x08
    13b0:	0c c0       	rjmp	.+24     	; 0x13ca <vListInsert+0x3a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13b2:	e8 01       	movw	r28, r16
    13b4:	23 96       	adiw	r28, 0x03	; 3
    13b6:	01 c0       	rjmp	.+2      	; 0x13ba <vListInsert+0x2a>
    13b8:	e9 01       	movw	r28, r18
    13ba:	2a 81       	ldd	r18, Y+2	; 0x02
    13bc:	3b 81       	ldd	r19, Y+3	; 0x03
    13be:	f9 01       	movw	r30, r18
    13c0:	40 81       	ld	r20, Z
    13c2:	51 81       	ldd	r21, Z+1	; 0x01
    13c4:	84 17       	cp	r24, r20
    13c6:	95 07       	cpc	r25, r21
    13c8:	b8 f7       	brcc	.-18     	; 0x13b8 <vListInsert+0x28>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    13ca:	8a 81       	ldd	r24, Y+2	; 0x02
    13cc:	9b 81       	ldd	r25, Y+3	; 0x03
    13ce:	13 96       	adiw	r26, 0x03	; 3
    13d0:	9c 93       	st	X, r25
    13d2:	8e 93       	st	-X, r24
    13d4:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    13d6:	fc 01       	movw	r30, r24
    13d8:	b5 83       	std	Z+5, r27	; 0x05
    13da:	a4 83       	std	Z+4, r26	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    13dc:	15 96       	adiw	r26, 0x05	; 5
    13de:	dc 93       	st	X, r29
    13e0:	ce 93       	st	-X, r28
    13e2:	14 97       	sbiw	r26, 0x04	; 4
	pxIterator->pxNext = pxNewListItem;
    13e4:	bb 83       	std	Y+3, r27	; 0x03
    13e6:	aa 83       	std	Y+2, r26	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    13e8:	19 96       	adiw	r26, 0x09	; 9
    13ea:	1c 93       	st	X, r17
    13ec:	0e 93       	st	-X, r16
    13ee:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    13f0:	f8 01       	movw	r30, r16
    13f2:	80 81       	ld	r24, Z
    13f4:	8f 5f       	subi	r24, 0xFF	; 255
    13f6:	80 83       	st	Z, r24
}
    13f8:	df 91       	pop	r29
    13fa:	cf 91       	pop	r28
    13fc:	1f 91       	pop	r17
    13fe:	0f 91       	pop	r16
    1400:	08 95       	ret

00001402 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove )
{
    1402:	cf 93       	push	r28
    1404:	df 93       	push	r29
    1406:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1408:	a2 81       	ldd	r26, Z+2	; 0x02
    140a:	b3 81       	ldd	r27, Z+3	; 0x03
    140c:	84 81       	ldd	r24, Z+4	; 0x04
    140e:	95 81       	ldd	r25, Z+5	; 0x05
    1410:	15 96       	adiw	r26, 0x05	; 5
    1412:	9c 93       	st	X, r25
    1414:	8e 93       	st	-X, r24
    1416:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1418:	c4 81       	ldd	r28, Z+4	; 0x04
    141a:	d5 81       	ldd	r29, Z+5	; 0x05
    141c:	bb 83       	std	Y+3, r27	; 0x03
    141e:	aa 83       	std	Y+2, r26	; 0x02

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1420:	a0 85       	ldd	r26, Z+8	; 0x08
    1422:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1424:	11 96       	adiw	r26, 0x01	; 1
    1426:	8d 91       	ld	r24, X+
    1428:	9c 91       	ld	r25, X
    142a:	12 97       	sbiw	r26, 0x02	; 2
    142c:	8e 17       	cp	r24, r30
    142e:	9f 07       	cpc	r25, r31
    1430:	21 f4       	brne	.+8      	; 0x143a <uxListRemove+0x38>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1432:	12 96       	adiw	r26, 0x02	; 2
    1434:	dc 93       	st	X, r29
    1436:	ce 93       	st	-X, r28
    1438:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    143a:	11 86       	std	Z+9, r1	; 0x09
    143c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    143e:	8c 91       	ld	r24, X
    1440:	81 50       	subi	r24, 0x01	; 1
    1442:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1444:	df 91       	pop	r29
    1446:	cf 91       	pop	r28
    1448:	08 95       	ret

0000144a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    144a:	af 92       	push	r10
    144c:	bf 92       	push	r11
    144e:	cf 92       	push	r12
    1450:	df 92       	push	r13
    1452:	ef 92       	push	r14
    1454:	ff 92       	push	r15
    1456:	0f 93       	push	r16
    1458:	1f 93       	push	r17
    145a:	cf 93       	push	r28
    145c:	df 93       	push	r29
    145e:	6c 01       	movw	r12, r24
    1460:	b6 2e       	mov	r11, r22
    1462:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1464:	8a e1       	ldi	r24, 0x1A	; 26
    1466:	90 e0       	ldi	r25, 0x00	; 0
    1468:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <pvPortMalloc>
    146c:	e8 2e       	mov	r14, r24
    146e:	e7 01       	movw	r28, r14
    1470:	7e 01       	movw	r14, r28
    1472:	f9 2e       	mov	r15, r25
    1474:	e7 01       	movw	r28, r14
	if( pxCoRoutine )
    1476:	20 97       	sbiw	r28, 0x00	; 0
    1478:	09 f4       	brne	.+2      	; 0x147c <xCoRoutineCreate+0x32>
    147a:	5e c0       	rjmp	.+188    	; 0x1538 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    147c:	80 91 67 01 	lds	r24, 0x0167
    1480:	90 91 68 01 	lds	r25, 0x0168
    1484:	00 97       	sbiw	r24, 0x00	; 0
    1486:	21 f5       	brne	.+72     	; 0x14d0 <xCoRoutineCreate+0x86>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1488:	f0 92 68 01 	sts	0x0168, r15
    148c:	e0 92 67 01 	sts	0x0167, r14
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1490:	83 e7       	ldi	r24, 0x73	; 115
    1492:	91 e0       	ldi	r25, 0x01	; 1
    1494:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
    1498:	8c e7       	ldi	r24, 0x7C	; 124
    149a:	91 e0       	ldi	r25, 0x01	; 1
    149c:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    14a0:	5f e8       	ldi	r21, 0x8F	; 143
    14a2:	e5 2e       	mov	r14, r21
    14a4:	51 e0       	ldi	r21, 0x01	; 1
    14a6:	f5 2e       	mov	r15, r21
    14a8:	c7 01       	movw	r24, r14
    14aa:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    14ae:	08 e9       	ldi	r16, 0x98	; 152
    14b0:	11 e0       	ldi	r17, 0x01	; 1
    14b2:	c8 01       	movw	r24, r16
    14b4:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    14b8:	89 e6       	ldi	r24, 0x69	; 105
    14ba:	91 e0       	ldi	r25, 0x01	; 1
    14bc:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    14c0:	f0 92 8c 01 	sts	0x018C, r15
    14c4:	e0 92 8b 01 	sts	0x018B, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    14c8:	10 93 8e 01 	sts	0x018E, r17
    14cc:	00 93 8d 01 	sts	0x018D, r16
    14d0:	bb 20       	and	r11, r11
    14d2:	11 f0       	breq	.+4      	; 0x14d8 <xCoRoutineCreate+0x8e>
    14d4:	bb 24       	eor	r11, r11
    14d6:	b3 94       	inc	r11
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    14d8:	19 8e       	std	Y+25, r1	; 0x19
    14da:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    14dc:	be 8a       	std	Y+22, r11	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    14de:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    14e0:	fe 01       	movw	r30, r28
    14e2:	c1 92       	st	Z+, r12
    14e4:	d1 92       	st	Z+, r13
    14e6:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    14e8:	cf 01       	movw	r24, r30
    14ea:	0e 94 a1 09 	call	0x1342	; 0x1342 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    14ee:	ce 01       	movw	r24, r28
    14f0:	0c 96       	adiw	r24, 0x0c	; 12
    14f2:	0e 94 a1 09 	call	0x1342	; 0x1342 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    14f6:	d9 87       	std	Y+9, r29	; 0x09
    14f8:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    14fa:	db 8b       	std	Y+19, r29	; 0x13
    14fc:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    14fe:	84 e0       	ldi	r24, 0x04	; 4
    1500:	90 e0       	ldi	r25, 0x00	; 0
    1502:	8b 19       	sub	r24, r11
    1504:	91 09       	sbc	r25, r1
    1506:	9d 87       	std	Y+13, r25	; 0x0d
    1508:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    150a:	2e 89       	ldd	r18, Y+22	; 0x16
    150c:	80 91 72 01 	lds	r24, 0x0172
    1510:	82 17       	cp	r24, r18
    1512:	10 f4       	brcc	.+4      	; 0x1518 <xCoRoutineCreate+0xce>
    1514:	20 93 72 01 	sts	0x0172, r18
    1518:	30 e0       	ldi	r19, 0x00	; 0
    151a:	c9 01       	movw	r24, r18
    151c:	43 e0       	ldi	r20, 0x03	; 3
    151e:	88 0f       	add	r24, r24
    1520:	99 1f       	adc	r25, r25
    1522:	4a 95       	dec	r20
    1524:	e1 f7       	brne	.-8      	; 0x151e <xCoRoutineCreate+0xd4>
    1526:	82 0f       	add	r24, r18
    1528:	93 1f       	adc	r25, r19
    152a:	8d 58       	subi	r24, 0x8D	; 141
    152c:	9e 4f       	sbci	r25, 0xFE	; 254
    152e:	b8 01       	movw	r22, r16
    1530:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInsertEnd>

		xReturn = pdPASS;
    1534:	81 e0       	ldi	r24, 0x01	; 1
    1536:	01 c0       	rjmp	.+2      	; 0x153a <xCoRoutineCreate+0xf0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1538:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    153a:	df 91       	pop	r29
    153c:	cf 91       	pop	r28
    153e:	1f 91       	pop	r17
    1540:	0f 91       	pop	r16
    1542:	ff 90       	pop	r15
    1544:	ef 90       	pop	r14
    1546:	df 90       	pop	r13
    1548:	cf 90       	pop	r12
    154a:	bf 90       	pop	r11
    154c:	af 90       	pop	r10
    154e:	08 95       	ret

00001550 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1550:	0f 93       	push	r16
    1552:	1f 93       	push	r17
    1554:	cf 93       	push	r28
    1556:	df 93       	push	r29
    1558:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    155a:	00 91 89 01 	lds	r16, 0x0189
    155e:	10 91 8a 01 	lds	r17, 0x018A
    1562:	08 0f       	add	r16, r24
    1564:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1566:	80 91 67 01 	lds	r24, 0x0167
    156a:	90 91 68 01 	lds	r25, 0x0168
    156e:	02 96       	adiw	r24, 0x02	; 2
    1570:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1574:	60 91 67 01 	lds	r22, 0x0167
    1578:	70 91 68 01 	lds	r23, 0x0168
    157c:	fb 01       	movw	r30, r22
    157e:	13 83       	std	Z+3, r17	; 0x03
    1580:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1582:	80 91 89 01 	lds	r24, 0x0189
    1586:	90 91 8a 01 	lds	r25, 0x018A
    158a:	6e 5f       	subi	r22, 0xFE	; 254
    158c:	7f 4f       	sbci	r23, 0xFF	; 255
    158e:	08 17       	cp	r16, r24
    1590:	19 07       	cpc	r17, r25
    1592:	28 f4       	brcc	.+10     	; 0x159e <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1594:	80 91 8d 01 	lds	r24, 0x018D
    1598:	90 91 8e 01 	lds	r25, 0x018E
    159c:	04 c0       	rjmp	.+8      	; 0x15a6 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    159e:	80 91 8b 01 	lds	r24, 0x018B
    15a2:	90 91 8c 01 	lds	r25, 0x018C
    15a6:	0e 94 c8 09 	call	0x1390	; 0x1390 <vListInsert>
	}

	if( pxEventList )
    15aa:	20 97       	sbiw	r28, 0x00	; 0
    15ac:	49 f0       	breq	.+18     	; 0x15c0 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    15ae:	60 91 67 01 	lds	r22, 0x0167
    15b2:	70 91 68 01 	lds	r23, 0x0168
    15b6:	64 5f       	subi	r22, 0xF4	; 244
    15b8:	7f 4f       	sbci	r23, 0xFF	; 255
    15ba:	ce 01       	movw	r24, r28
    15bc:	0e 94 c8 09 	call	0x1390	; 0x1390 <vListInsert>
	}
}
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	1f 91       	pop	r17
    15c6:	0f 91       	pop	r16
    15c8:	08 95       	ret

000015ca <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    15ca:	0f 93       	push	r16
    15cc:	1f 93       	push	r17
    15ce:	cf 93       	push	r28
    15d0:	df 93       	push	r29
    15d2:	27 c0       	rjmp	.+78     	; 0x1622 <vCoRoutineSchedule+0x58>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    15d4:	f8 94       	cli
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    15d6:	e0 91 6e 01 	lds	r30, 0x016E
    15da:	f0 91 6f 01 	lds	r31, 0x016F
    15de:	c6 81       	ldd	r28, Z+6	; 0x06
    15e0:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    15e2:	ce 01       	movw	r24, r28
    15e4:	0c 96       	adiw	r24, 0x0c	; 12
    15e6:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    15ea:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    15ec:	8e 01       	movw	r16, r28
    15ee:	0e 5f       	subi	r16, 0xFE	; 254
    15f0:	1f 4f       	sbci	r17, 0xFF	; 255
    15f2:	c8 01       	movw	r24, r16
    15f4:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    15f8:	2e 89       	ldd	r18, Y+22	; 0x16
    15fa:	80 91 72 01 	lds	r24, 0x0172
    15fe:	82 17       	cp	r24, r18
    1600:	10 f4       	brcc	.+4      	; 0x1606 <vCoRoutineSchedule+0x3c>
    1602:	20 93 72 01 	sts	0x0172, r18
    1606:	30 e0       	ldi	r19, 0x00	; 0
    1608:	c9 01       	movw	r24, r18
    160a:	f3 e0       	ldi	r31, 0x03	; 3
    160c:	88 0f       	add	r24, r24
    160e:	99 1f       	adc	r25, r25
    1610:	fa 95       	dec	r31
    1612:	e1 f7       	brne	.-8      	; 0x160c <vCoRoutineSchedule+0x42>
    1614:	82 0f       	add	r24, r18
    1616:	93 1f       	adc	r25, r19
    1618:	8d 58       	subi	r24, 0x8D	; 141
    161a:	9e 4f       	sbci	r25, 0xFE	; 254
    161c:	b8 01       	movw	r22, r16
    161e:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1622:	80 91 69 01 	lds	r24, 0x0169
    1626:	88 23       	and	r24, r24
    1628:	a9 f6       	brne	.-86     	; 0x15d4 <vCoRoutineSchedule+0xa>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    162a:	0e 94 50 02 	call	0x4a0	; 0x4a0 <xTaskGetTickCount>
    162e:	20 91 85 01 	lds	r18, 0x0185
    1632:	30 91 86 01 	lds	r19, 0x0186
    1636:	82 1b       	sub	r24, r18
    1638:	93 0b       	sbc	r25, r19
    163a:	90 93 88 01 	sts	0x0188, r25
    163e:	80 93 87 01 	sts	0x0187, r24
    1642:	59 c0       	rjmp	.+178    	; 0x16f6 <vCoRoutineSchedule+0x12c>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    1644:	01 96       	adiw	r24, 0x01	; 1
    1646:	90 93 8a 01 	sts	0x018A, r25
    164a:	80 93 89 01 	sts	0x0189, r24
		xPassedTicks--;
    164e:	21 50       	subi	r18, 0x01	; 1
    1650:	30 40       	sbci	r19, 0x00	; 0
    1652:	30 93 88 01 	sts	0x0188, r19
    1656:	20 93 87 01 	sts	0x0187, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    165a:	00 97       	sbiw	r24, 0x00	; 0
    165c:	09 f0       	breq	.+2      	; 0x1660 <vCoRoutineSchedule+0x96>
    165e:	44 c0       	rjmp	.+136    	; 0x16e8 <vCoRoutineSchedule+0x11e>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1660:	80 91 8b 01 	lds	r24, 0x018B
    1664:	90 91 8c 01 	lds	r25, 0x018C
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1668:	20 91 8d 01 	lds	r18, 0x018D
    166c:	30 91 8e 01 	lds	r19, 0x018E
    1670:	30 93 8c 01 	sts	0x018C, r19
    1674:	20 93 8b 01 	sts	0x018B, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    1678:	90 93 8e 01 	sts	0x018E, r25
    167c:	80 93 8d 01 	sts	0x018D, r24
    1680:	33 c0       	rjmp	.+102    	; 0x16e8 <vCoRoutineSchedule+0x11e>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1682:	05 80       	ldd	r0, Z+5	; 0x05
    1684:	f6 81       	ldd	r31, Z+6	; 0x06
    1686:	e0 2d       	mov	r30, r0
    1688:	c6 81       	ldd	r28, Z+6	; 0x06
    168a:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    168c:	20 91 89 01 	lds	r18, 0x0189
    1690:	30 91 8a 01 	lds	r19, 0x018A
    1694:	8a 81       	ldd	r24, Y+2	; 0x02
    1696:	9b 81       	ldd	r25, Y+3	; 0x03
    1698:	28 17       	cp	r18, r24
    169a:	39 07       	cpc	r19, r25
    169c:	60 f1       	brcs	.+88     	; 0x16f6 <vCoRoutineSchedule+0x12c>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    169e:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
    16a0:	8e 01       	movw	r16, r28
    16a2:	0e 5f       	subi	r16, 0xFE	; 254
    16a4:	1f 4f       	sbci	r17, 0xFF	; 255
    16a6:	c8 01       	movw	r24, r16
    16a8:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    16ac:	8c 89       	ldd	r24, Y+20	; 0x14
    16ae:	9d 89       	ldd	r25, Y+21	; 0x15
    16b0:	00 97       	sbiw	r24, 0x00	; 0
    16b2:	21 f0       	breq	.+8      	; 0x16bc <vCoRoutineSchedule+0xf2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    16b4:	ce 01       	movw	r24, r28
    16b6:	0c 96       	adiw	r24, 0x0c	; 12
    16b8:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    16bc:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    16be:	2e 89       	ldd	r18, Y+22	; 0x16
    16c0:	80 91 72 01 	lds	r24, 0x0172
    16c4:	82 17       	cp	r24, r18
    16c6:	10 f4       	brcc	.+4      	; 0x16cc <vCoRoutineSchedule+0x102>
    16c8:	20 93 72 01 	sts	0x0172, r18
    16cc:	30 e0       	ldi	r19, 0x00	; 0
    16ce:	c9 01       	movw	r24, r18
    16d0:	e3 e0       	ldi	r30, 0x03	; 3
    16d2:	88 0f       	add	r24, r24
    16d4:	99 1f       	adc	r25, r25
    16d6:	ea 95       	dec	r30
    16d8:	e1 f7       	brne	.-8      	; 0x16d2 <vCoRoutineSchedule+0x108>
    16da:	82 0f       	add	r24, r18
    16dc:	93 1f       	adc	r25, r19
    16de:	8d 58       	subi	r24, 0x8D	; 141
    16e0:	9e 4f       	sbci	r25, 0xFE	; 254
    16e2:	b8 01       	movw	r22, r16
    16e4:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    16e8:	e0 91 8b 01 	lds	r30, 0x018B
    16ec:	f0 91 8c 01 	lds	r31, 0x018C
    16f0:	80 81       	ld	r24, Z
    16f2:	88 23       	and	r24, r24
    16f4:	31 f6       	brne	.-116    	; 0x1682 <vCoRoutineSchedule+0xb8>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    16f6:	20 91 87 01 	lds	r18, 0x0187
    16fa:	30 91 88 01 	lds	r19, 0x0188
    16fe:	80 91 89 01 	lds	r24, 0x0189
    1702:	90 91 8a 01 	lds	r25, 0x018A
    1706:	21 15       	cp	r18, r1
    1708:	31 05       	cpc	r19, r1
    170a:	09 f0       	breq	.+2      	; 0x170e <vCoRoutineSchedule+0x144>
    170c:	9b cf       	rjmp	.-202    	; 0x1644 <vCoRoutineSchedule+0x7a>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    170e:	90 93 86 01 	sts	0x0186, r25
    1712:	80 93 85 01 	sts	0x0185, r24
    1716:	40 91 72 01 	lds	r20, 0x0172

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    171a:	06 c0       	rjmp	.+12     	; 0x1728 <vCoRoutineSchedule+0x15e>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    171c:	44 23       	and	r20, r20
    171e:	19 f4       	brne	.+6      	; 0x1726 <vCoRoutineSchedule+0x15c>
    1720:	10 92 72 01 	sts	0x0172, r1
    1724:	40 c0       	rjmp	.+128    	; 0x17a6 <vCoRoutineSchedule+0x1dc>
    1726:	41 50       	subi	r20, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1728:	84 2f       	mov	r24, r20
    172a:	90 e0       	ldi	r25, 0x00	; 0
    172c:	9c 01       	movw	r18, r24
    172e:	73 e0       	ldi	r23, 0x03	; 3
    1730:	22 0f       	add	r18, r18
    1732:	33 1f       	adc	r19, r19
    1734:	7a 95       	dec	r23
    1736:	e1 f7       	brne	.-8      	; 0x1730 <vCoRoutineSchedule+0x166>
    1738:	28 0f       	add	r18, r24
    173a:	39 1f       	adc	r19, r25
    173c:	f9 01       	movw	r30, r18
    173e:	ed 58       	subi	r30, 0x8D	; 141
    1740:	fe 4f       	sbci	r31, 0xFE	; 254
    1742:	50 81       	ld	r21, Z
    1744:	55 23       	and	r21, r21
    1746:	51 f3       	breq	.-44     	; 0x171c <vCoRoutineSchedule+0x152>
    1748:	40 93 72 01 	sts	0x0172, r20
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    174c:	a1 81       	ldd	r26, Z+1	; 0x01
    174e:	b2 81       	ldd	r27, Z+2	; 0x02
    1750:	12 96       	adiw	r26, 0x02	; 2
    1752:	0d 90       	ld	r0, X+
    1754:	bc 91       	ld	r27, X
    1756:	a0 2d       	mov	r26, r0
    1758:	b2 83       	std	Z+2, r27	; 0x02
    175a:	a1 83       	std	Z+1, r26	; 0x01
    175c:	2a 58       	subi	r18, 0x8A	; 138
    175e:	3e 4f       	sbci	r19, 0xFE	; 254
    1760:	a2 17       	cp	r26, r18
    1762:	b3 07       	cpc	r27, r19
    1764:	31 f4       	brne	.+12     	; 0x1772 <vCoRoutineSchedule+0x1a8>
    1766:	12 96       	adiw	r26, 0x02	; 2
    1768:	2d 91       	ld	r18, X+
    176a:	3c 91       	ld	r19, X
    176c:	13 97       	sbiw	r26, 0x03	; 3
    176e:	32 83       	std	Z+2, r19	; 0x02
    1770:	21 83       	std	Z+1, r18	; 0x01
    1772:	fc 01       	movw	r30, r24
    1774:	63 e0       	ldi	r22, 0x03	; 3
    1776:	ee 0f       	add	r30, r30
    1778:	ff 1f       	adc	r31, r31
    177a:	6a 95       	dec	r22
    177c:	e1 f7       	brne	.-8      	; 0x1776 <vCoRoutineSchedule+0x1ac>
    177e:	e8 0f       	add	r30, r24
    1780:	f9 1f       	adc	r31, r25
    1782:	ed 58       	subi	r30, 0x8D	; 141
    1784:	fe 4f       	sbci	r31, 0xFE	; 254
    1786:	01 80       	ldd	r0, Z+1	; 0x01
    1788:	f2 81       	ldd	r31, Z+2	; 0x02
    178a:	e0 2d       	mov	r30, r0
    178c:	a6 81       	ldd	r26, Z+6	; 0x06
    178e:	b7 81       	ldd	r27, Z+7	; 0x07
    1790:	b0 93 68 01 	sts	0x0168, r27
    1794:	a0 93 67 01 	sts	0x0167, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1798:	ed 91       	ld	r30, X+
    179a:	fc 91       	ld	r31, X
    179c:	11 97       	sbiw	r26, 0x01	; 1
    179e:	cd 01       	movw	r24, r26
    17a0:	57 96       	adiw	r26, 0x17	; 23
    17a2:	6c 91       	ld	r22, X
    17a4:	09 95       	icall

	return;
}
    17a6:	df 91       	pop	r29
    17a8:	cf 91       	pop	r28
    17aa:	1f 91       	pop	r17
    17ac:	0f 91       	pop	r16
    17ae:	08 95       	ret

000017b0 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    17b0:	0f 93       	push	r16
    17b2:	1f 93       	push	r17
    17b4:	cf 93       	push	r28
    17b6:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    17b8:	dc 01       	movw	r26, r24
    17ba:	15 96       	adiw	r26, 0x05	; 5
    17bc:	ed 91       	ld	r30, X+
    17be:	fc 91       	ld	r31, X
    17c0:	16 97       	sbiw	r26, 0x06	; 6
    17c2:	c6 81       	ldd	r28, Z+6	; 0x06
    17c4:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    17c6:	8e 01       	movw	r16, r28
    17c8:	04 5f       	subi	r16, 0xF4	; 244
    17ca:	1f 4f       	sbci	r17, 0xFF	; 255
    17cc:	c8 01       	movw	r24, r16
    17ce:	0e 94 01 0a 	call	0x1402	; 0x1402 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    17d2:	89 e6       	ldi	r24, 0x69	; 105
    17d4:	91 e0       	ldi	r25, 0x01	; 1
    17d6:	b8 01       	movw	r22, r16
    17d8:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    17dc:	e0 91 67 01 	lds	r30, 0x0167
    17e0:	f0 91 68 01 	lds	r31, 0x0168
	{
		xReturn = pdTRUE;
    17e4:	81 e0       	ldi	r24, 0x01	; 1
    17e6:	2e 89       	ldd	r18, Y+22	; 0x16
    17e8:	96 89       	ldd	r25, Z+22	; 0x16
    17ea:	29 17       	cp	r18, r25
    17ec:	08 f4       	brcc	.+2      	; 0x17f0 <xCoRoutineRemoveFromEventList+0x40>
    17ee:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    17f0:	df 91       	pop	r29
    17f2:	cf 91       	pop	r28
    17f4:	1f 91       	pop	r17
    17f6:	0f 91       	pop	r16
    17f8:	08 95       	ret

000017fa <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    17fa:	ef 92       	push	r14
    17fc:	ff 92       	push	r15
    17fe:	cf 93       	push	r28
    1800:	df 93       	push	r29
    1802:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1804:	0e 94 4a 02 	call	0x494	; 0x494 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1808:	80 91 7f 07 	lds	r24, 0x077F
    180c:	90 91 80 07 	lds	r25, 0x0780
    1810:	00 97       	sbiw	r24, 0x00	; 0
    1812:	31 f4       	brne	.+12     	; 0x1820 <pvPortMalloc+0x26>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    1814:	84 ea       	ldi	r24, 0xA4	; 164
    1816:	91 e0       	ldi	r25, 0x01	; 1
    1818:	90 93 80 07 	sts	0x0780, r25
    181c:	80 93 7f 07 	sts	0x077F, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1820:	20 91 a1 01 	lds	r18, 0x01A1
    1824:	30 91 a2 01 	lds	r19, 0x01A2
    1828:	ce 01       	movw	r24, r28
    182a:	82 0f       	add	r24, r18
    182c:	93 1f       	adc	r25, r19
    182e:	45 e0       	ldi	r20, 0x05	; 5
    1830:	8b 3d       	cpi	r24, 0xDB	; 219
    1832:	94 07       	cpc	r25, r20
    1834:	70 f4       	brcc	.+28     	; 0x1852 <pvPortMalloc+0x58>
    1836:	28 17       	cp	r18, r24
    1838:	39 07       	cpc	r19, r25
    183a:	58 f4       	brcc	.+22     	; 0x1852 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    183c:	c0 91 7f 07 	lds	r28, 0x077F
    1840:	d0 91 80 07 	lds	r29, 0x0780
    1844:	c2 0f       	add	r28, r18
    1846:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    1848:	90 93 a2 01 	sts	0x01A2, r25
    184c:	80 93 a1 01 	sts	0x01A1, r24
    1850:	02 c0       	rjmp	.+4      	; 0x1856 <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1852:	c0 e0       	ldi	r28, 0x00	; 0
    1854:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}	
	xTaskResumeAll();
    1856:	0e 94 46 03 	call	0x68c	; 0x68c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    185a:	ce 01       	movw	r24, r28
    185c:	df 91       	pop	r29
    185e:	cf 91       	pop	r28
    1860:	ff 90       	pop	r15
    1862:	ef 90       	pop	r14
    1864:	08 95       	ret

00001866 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1866:	08 95       	ret

00001868 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1868:	10 92 a2 01 	sts	0x01A2, r1
    186c:	10 92 a1 01 	sts	0x01A1, r1
}
    1870:	08 95       	ret

00001872 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1872:	2b ed       	ldi	r18, 0xDB	; 219
    1874:	35 e0       	ldi	r19, 0x05	; 5
    1876:	80 91 a1 01 	lds	r24, 0x01A1
    187a:	90 91 a2 01 	lds	r25, 0x01A2
    187e:	28 1b       	sub	r18, r24
    1880:	39 0b       	sbc	r19, r25
}
    1882:	c9 01       	movw	r24, r18
    1884:	08 95       	ret

00001886 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1886:	21 e1       	ldi	r18, 0x11	; 17
    1888:	fc 01       	movw	r30, r24
    188a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    188c:	92 e2       	ldi	r25, 0x22	; 34
    188e:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1890:	83 e3       	ldi	r24, 0x33	; 51
    1892:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1894:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1896:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1898:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    189a:	80 e8       	ldi	r24, 0x80	; 128
    189c:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    189e:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    18a0:	82 e0       	ldi	r24, 0x02	; 2
    18a2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    18a4:	83 e0       	ldi	r24, 0x03	; 3
    18a6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    18a8:	84 e0       	ldi	r24, 0x04	; 4
    18aa:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    18ac:	85 e0       	ldi	r24, 0x05	; 5
    18ae:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    18b0:	86 e0       	ldi	r24, 0x06	; 6
    18b2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    18b4:	87 e0       	ldi	r24, 0x07	; 7
    18b6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    18b8:	88 e0       	ldi	r24, 0x08	; 8
    18ba:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    18bc:	89 e0       	ldi	r24, 0x09	; 9
    18be:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    18c0:	80 e1       	ldi	r24, 0x10	; 16
    18c2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    18c4:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    18c6:	82 e1       	ldi	r24, 0x12	; 18
    18c8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    18ca:	83 e1       	ldi	r24, 0x13	; 19
    18cc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    18ce:	84 e1       	ldi	r24, 0x14	; 20
    18d0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    18d2:	85 e1       	ldi	r24, 0x15	; 21
    18d4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    18d6:	86 e1       	ldi	r24, 0x16	; 22
    18d8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    18da:	87 e1       	ldi	r24, 0x17	; 23
    18dc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    18de:	88 e1       	ldi	r24, 0x18	; 24
    18e0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    18e2:	89 e1       	ldi	r24, 0x19	; 25
    18e4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    18e6:	80 e2       	ldi	r24, 0x20	; 32
    18e8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    18ea:	81 e2       	ldi	r24, 0x21	; 33
    18ec:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    18ee:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    18f0:	83 e2       	ldi	r24, 0x23	; 35
    18f2:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    18f4:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    18f6:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    18f8:	86 e2       	ldi	r24, 0x26	; 38
    18fa:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    18fc:	87 e2       	ldi	r24, 0x27	; 39
    18fe:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1900:	88 e2       	ldi	r24, 0x28	; 40
    1902:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1904:	89 e2       	ldi	r24, 0x29	; 41
    1906:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1908:	80 e3       	ldi	r24, 0x30	; 48
    190a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    190c:	81 e3       	ldi	r24, 0x31	; 49
    190e:	82 93       	st	-Z, r24
	pxTopOfStack--;
    1910:	9f 01       	movw	r18, r30
    1912:	21 50       	subi	r18, 0x01	; 1
    1914:	30 40       	sbci	r19, 0x00	; 0

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    1916:	c9 01       	movw	r24, r18
    1918:	08 95       	ret

0000191a <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled
	before this is called so we need not worry here. */
	OCR1A = ulCompareMatch;
    191a:	89 ef       	ldi	r24, 0xF9	; 249
    191c:	90 e0       	ldi	r25, 0x00	; 0
    191e:	90 93 89 00 	sts	0x0089, r25
    1922:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    1926:	e0 e8       	ldi	r30, 0x80	; 128
    1928:	f0 e0       	ldi	r31, 0x00	; 0
    192a:	80 81       	ld	r24, Z
    192c:	8c 7f       	andi	r24, 0xFC	; 252
    192e:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    1930:	8b e0       	ldi	r24, 0x0B	; 11
    1932:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    1936:	ef e6       	ldi	r30, 0x6F	; 111
    1938:	f0 e0       	ldi	r31, 0x00	; 0
    193a:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    193c:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    193e:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1940:	a0 91 0e 01 	lds	r26, 0x010E
    1944:	b0 91 0f 01 	lds	r27, 0x010F
    1948:	cd 91       	ld	r28, X+
    194a:	cd bf       	out	0x3d, r28	; 61
    194c:	dd 91       	ld	r29, X+
    194e:	de bf       	out	0x3e, r29	; 62
    1950:	ff 91       	pop	r31
    1952:	ef 91       	pop	r30
    1954:	df 91       	pop	r29
    1956:	cf 91       	pop	r28
    1958:	bf 91       	pop	r27
    195a:	af 91       	pop	r26
    195c:	9f 91       	pop	r25
    195e:	8f 91       	pop	r24
    1960:	7f 91       	pop	r23
    1962:	6f 91       	pop	r22
    1964:	5f 91       	pop	r21
    1966:	4f 91       	pop	r20
    1968:	3f 91       	pop	r19
    196a:	2f 91       	pop	r18
    196c:	1f 91       	pop	r17
    196e:	0f 91       	pop	r16
    1970:	ff 90       	pop	r15
    1972:	ef 90       	pop	r14
    1974:	df 90       	pop	r13
    1976:	cf 90       	pop	r12
    1978:	bf 90       	pop	r11
    197a:	af 90       	pop	r10
    197c:	9f 90       	pop	r9
    197e:	8f 90       	pop	r8
    1980:	7f 90       	pop	r7
    1982:	6f 90       	pop	r6
    1984:	5f 90       	pop	r5
    1986:	4f 90       	pop	r4
    1988:	3f 90       	pop	r3
    198a:	2f 90       	pop	r2
    198c:	1f 90       	pop	r1
    198e:	0f 90       	pop	r0
    1990:	0f be       	out	0x3f, r0	; 63
    1992:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1994:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1996:	81 e0       	ldi	r24, 0x01	; 1
    1998:	08 95       	ret

0000199a <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    199a:	08 95       	ret

0000199c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    199c:	0f 92       	push	r0
    199e:	0f b6       	in	r0, 0x3f	; 63
    19a0:	f8 94       	cli
    19a2:	0f 92       	push	r0
    19a4:	1f 92       	push	r1
    19a6:	11 24       	eor	r1, r1
    19a8:	2f 92       	push	r2
    19aa:	3f 92       	push	r3
    19ac:	4f 92       	push	r4
    19ae:	5f 92       	push	r5
    19b0:	6f 92       	push	r6
    19b2:	7f 92       	push	r7
    19b4:	8f 92       	push	r8
    19b6:	9f 92       	push	r9
    19b8:	af 92       	push	r10
    19ba:	bf 92       	push	r11
    19bc:	cf 92       	push	r12
    19be:	df 92       	push	r13
    19c0:	ef 92       	push	r14
    19c2:	ff 92       	push	r15
    19c4:	0f 93       	push	r16
    19c6:	1f 93       	push	r17
    19c8:	2f 93       	push	r18
    19ca:	3f 93       	push	r19
    19cc:	4f 93       	push	r20
    19ce:	5f 93       	push	r21
    19d0:	6f 93       	push	r22
    19d2:	7f 93       	push	r23
    19d4:	8f 93       	push	r24
    19d6:	9f 93       	push	r25
    19d8:	af 93       	push	r26
    19da:	bf 93       	push	r27
    19dc:	cf 93       	push	r28
    19de:	df 93       	push	r29
    19e0:	ef 93       	push	r30
    19e2:	ff 93       	push	r31
    19e4:	a0 91 0e 01 	lds	r26, 0x010E
    19e8:	b0 91 0f 01 	lds	r27, 0x010F
    19ec:	0d b6       	in	r0, 0x3d	; 61
    19ee:	0d 92       	st	X+, r0
    19f0:	0e b6       	in	r0, 0x3e	; 62
    19f2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    19f4:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    19f8:	a0 91 0e 01 	lds	r26, 0x010E
    19fc:	b0 91 0f 01 	lds	r27, 0x010F
    1a00:	cd 91       	ld	r28, X+
    1a02:	cd bf       	out	0x3d, r28	; 61
    1a04:	dd 91       	ld	r29, X+
    1a06:	de bf       	out	0x3e, r29	; 62
    1a08:	ff 91       	pop	r31
    1a0a:	ef 91       	pop	r30
    1a0c:	df 91       	pop	r29
    1a0e:	cf 91       	pop	r28
    1a10:	bf 91       	pop	r27
    1a12:	af 91       	pop	r26
    1a14:	9f 91       	pop	r25
    1a16:	8f 91       	pop	r24
    1a18:	7f 91       	pop	r23
    1a1a:	6f 91       	pop	r22
    1a1c:	5f 91       	pop	r21
    1a1e:	4f 91       	pop	r20
    1a20:	3f 91       	pop	r19
    1a22:	2f 91       	pop	r18
    1a24:	1f 91       	pop	r17
    1a26:	0f 91       	pop	r16
    1a28:	ff 90       	pop	r15
    1a2a:	ef 90       	pop	r14
    1a2c:	df 90       	pop	r13
    1a2e:	cf 90       	pop	r12
    1a30:	bf 90       	pop	r11
    1a32:	af 90       	pop	r10
    1a34:	9f 90       	pop	r9
    1a36:	8f 90       	pop	r8
    1a38:	7f 90       	pop	r7
    1a3a:	6f 90       	pop	r6
    1a3c:	5f 90       	pop	r5
    1a3e:	4f 90       	pop	r4
    1a40:	3f 90       	pop	r3
    1a42:	2f 90       	pop	r2
    1a44:	1f 90       	pop	r1
    1a46:	0f 90       	pop	r0
    1a48:	0f be       	out	0x3f, r0	; 63
    1a4a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1a4c:	08 95       	ret

00001a4e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1a4e:	0f 92       	push	r0
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	f8 94       	cli
    1a54:	0f 92       	push	r0
    1a56:	1f 92       	push	r1
    1a58:	11 24       	eor	r1, r1
    1a5a:	2f 92       	push	r2
    1a5c:	3f 92       	push	r3
    1a5e:	4f 92       	push	r4
    1a60:	5f 92       	push	r5
    1a62:	6f 92       	push	r6
    1a64:	7f 92       	push	r7
    1a66:	8f 92       	push	r8
    1a68:	9f 92       	push	r9
    1a6a:	af 92       	push	r10
    1a6c:	bf 92       	push	r11
    1a6e:	cf 92       	push	r12
    1a70:	df 92       	push	r13
    1a72:	ef 92       	push	r14
    1a74:	ff 92       	push	r15
    1a76:	0f 93       	push	r16
    1a78:	1f 93       	push	r17
    1a7a:	2f 93       	push	r18
    1a7c:	3f 93       	push	r19
    1a7e:	4f 93       	push	r20
    1a80:	5f 93       	push	r21
    1a82:	6f 93       	push	r22
    1a84:	7f 93       	push	r23
    1a86:	8f 93       	push	r24
    1a88:	9f 93       	push	r25
    1a8a:	af 93       	push	r26
    1a8c:	bf 93       	push	r27
    1a8e:	cf 93       	push	r28
    1a90:	df 93       	push	r29
    1a92:	ef 93       	push	r30
    1a94:	ff 93       	push	r31
    1a96:	a0 91 0e 01 	lds	r26, 0x010E
    1a9a:	b0 91 0f 01 	lds	r27, 0x010F
    1a9e:	0d b6       	in	r0, 0x3d	; 61
    1aa0:	0d 92       	st	X+, r0
    1aa2:	0e b6       	in	r0, 0x3e	; 62
    1aa4:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1aa6:	0e 94 64 02 	call	0x4c8	; 0x4c8 <xTaskIncrementTick>
    1aaa:	88 23       	and	r24, r24
    1aac:	11 f0       	breq	.+4      	; 0x1ab2 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1aae:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1ab2:	a0 91 0e 01 	lds	r26, 0x010E
    1ab6:	b0 91 0f 01 	lds	r27, 0x010F
    1aba:	cd 91       	ld	r28, X+
    1abc:	cd bf       	out	0x3d, r28	; 61
    1abe:	dd 91       	ld	r29, X+
    1ac0:	de bf       	out	0x3e, r29	; 62
    1ac2:	ff 91       	pop	r31
    1ac4:	ef 91       	pop	r30
    1ac6:	df 91       	pop	r29
    1ac8:	cf 91       	pop	r28
    1aca:	bf 91       	pop	r27
    1acc:	af 91       	pop	r26
    1ace:	9f 91       	pop	r25
    1ad0:	8f 91       	pop	r24
    1ad2:	7f 91       	pop	r23
    1ad4:	6f 91       	pop	r22
    1ad6:	5f 91       	pop	r21
    1ad8:	4f 91       	pop	r20
    1ada:	3f 91       	pop	r19
    1adc:	2f 91       	pop	r18
    1ade:	1f 91       	pop	r17
    1ae0:	0f 91       	pop	r16
    1ae2:	ff 90       	pop	r15
    1ae4:	ef 90       	pop	r14
    1ae6:	df 90       	pop	r13
    1ae8:	cf 90       	pop	r12
    1aea:	bf 90       	pop	r11
    1aec:	af 90       	pop	r10
    1aee:	9f 90       	pop	r9
    1af0:	8f 90       	pop	r8
    1af2:	7f 90       	pop	r7
    1af4:	6f 90       	pop	r6
    1af6:	5f 90       	pop	r5
    1af8:	4f 90       	pop	r4
    1afa:	3f 90       	pop	r3
    1afc:	2f 90       	pop	r2
    1afe:	1f 90       	pop	r1
    1b00:	0f 90       	pop	r0
    1b02:	0f be       	out	0x3f, r0	; 63
    1b04:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b06:	08 95       	ret

00001b08 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
    void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1b08:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <vPortYieldFromTick>
		asm volatile ( "reti" );
    1b0c:	18 95       	reti

00001b0e <memcpy>:
    1b0e:	fb 01       	movw	r30, r22
    1b10:	dc 01       	movw	r26, r24
    1b12:	02 c0       	rjmp	.+4      	; 0x1b18 <memcpy+0xa>
    1b14:	01 90       	ld	r0, Z+
    1b16:	0d 92       	st	X+, r0
    1b18:	41 50       	subi	r20, 0x01	; 1
    1b1a:	50 40       	sbci	r21, 0x00	; 0
    1b1c:	d8 f7       	brcc	.-10     	; 0x1b14 <memcpy+0x6>
    1b1e:	08 95       	ret

00001b20 <memset>:
    1b20:	dc 01       	movw	r26, r24
    1b22:	01 c0       	rjmp	.+2      	; 0x1b26 <memset+0x6>
    1b24:	6d 93       	st	X+, r22
    1b26:	41 50       	subi	r20, 0x01	; 1
    1b28:	50 40       	sbci	r21, 0x00	; 0
    1b2a:	e0 f7       	brcc	.-8      	; 0x1b24 <memset+0x4>
    1b2c:	08 95       	ret

00001b2e <_exit>:
    1b2e:	f8 94       	cli

00001b30 <__stop_program>:
    1b30:	ff cf       	rjmp	.-2      	; 0x1b30 <__stop_program>
